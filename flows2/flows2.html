<!DOCTYPE html>
<html>

<head>
    <meta charset="UTF-8">
    <title>Flows2</title>
<!--     <script type="text/javascript" src="lazy.js"></script>
 -->    <!-- optional: if you want support for DOM event and AJAX-based sequences: -->
<!--     <script type="text/javascript" src="lazy.browser.js"></script>
 -->    <script type="text/javascript" src="moment-with-locales.js"></script>
 <script type="text/javascript" src="lodash.js"></script>
    <script type="text/javascript" src="flows2.js"></script>
    <script type="text/javascript">


let start =  moment('20170104' , 'YYYYMMDD' )
let end = moment('20171231' , 'YYYYMMDD' )

function getMergedFlows(start,end,contracts,accounts, units, contractProto) 
{ 
    let days=genDays(start,end)
    let normalisedContracts = normaliseContracts(contracts, days, accounts, units, contractProto)
    // => { "20170208": {  unit:"chf", flow:-1.0, balance:1.0 } }
    // each day until end date
    //  walk contracts recursively gather flows for current day: => merge per day: contract 1 and 2: add all same days together (respect currency conversion)
    // __.mapKeys(days, (value, day) => {
    //     return getMergedFlow(day, normalisedContracts,accounts, units, contractProto); 
    // })
    return normalisedContracts

}
function genDays(start, end) {
    let array=Array.apply(0, Array(Math.round(moment.duration(end.diff(start)).asDays()) ))
    return array.reduce((object, item, index)=>{  day=moment(start).add(index,'days'); object[day.format('YYYYMMDD')]={}; return object}, {})
}
function normaliseContracts(contracts, days, accounts, units, contractProto) {
    // go down if contract and in account generate flows
     _.forOwn(contracts, (value, prop) => {
        if (typeof value === "object" && contractProto[prop]===undefined) {
            let subContract = contracts[prop]
            subContract = inherit({}, subContract, filter(contracts, contractProto))
            //subContract.flows = genFlows(subContract, days, accounts)
            contracts[prop] = normaliseContracts(subContract,days, accounts, units, contractProto)
        }

    })
    contracts = inherit(contracts, filter(contracts, contractProto))
    contracts.flows = genFlows(contracts, days, accounts, units)
    return contracts; 
}

function findPropOnObject(prop, source) {
    for (var property in source) {
        let found=undefined
        if (prop == property) {
           found= source[property];
        } else if (typeof source[property] === "object" ) { 
            found=findPropOnObject(prop, source[property]);
        }
        if (found)
            return found
    }
    return undefined        
}
function genFlows(normalisedContract, days, accounts, units) {
    let flows = []
    if (accounts && units && !findPropOnObject(normalisedContract.acct, accounts) )
        return flows;

    // gen seq
    let sequence = getFlowSeq(normalisedContract, days)
    return _.reduce(sequence, (flows, item, index)=>{ 
        let targetUnit;
        if (accounts)
            targetUnit = findPropOnObject("unit", accounts)
        let flow = {}
        flow.flow = normalisedContract.amount
        flow.unit = normalisedContract.unit
        flows[index] = flow;
        if (targetUnit)
            flow.flow=convert(flow.flow, flow.unit, units, targetUnit) 

        ; return flows; 
    },{})
}
function getFlowSeq(normalisedContract, days) {
    let flows = {}
    let first =_.chain(days).keys().head().value()
    let last = _.findLastKey(days)
    
    
    let current = normalisedContract.start
    while (current <= last) {
        if (current >= first)
            flows[current] = {}
        let oldcurrent=current
        current = moment(current, 'YYYYMMDD').add(1, normalisedContract.rythm).format('YYYYMMDD')
        if (oldcurrent==current)
         {
            throw "constant current date :"+current+" "+normalisedContract            
         }
    }
    return flows
}
// deep copy of undefined attributes
function inherit(source, extension, target) {
    if (!target)
        target={}
    
    return inheritClone(inheritClone(target, source ), extension)
}
// deep copy, but not overwriting dest leaves
function inheritClone(source, destination, deep) {
    for (var property in source) {
        if ( destination[property]===undefined) {
            if (typeof source[property] === "object" && deep) { 
                destination[property] = {}
                inheritClone(source[property], destination[property]);
            } else {
                destination[property] = source[property];
            }
        }
    }
    return destination
}
function filter(source, objectProto) {
    let destination={}
    for (var property in source) {
        if (objectProto[property] ===null ) { 
            destination[property] = source[property];
        }
    }
    return destination

}

let testContract = {
    acct: "zahlungs",
    unit: "chf",
    rythm: "M",
    start: "20170104", 
    amount:184,
    parking: {
        amount:150,
    },
    oil: {
        rythm: "y",
        start: "20171101", 
        amount:200,
    },
    fluid: {
        rythm: "Q",
        start: "20170114", 
        amount:20,
    },
    test: {
        rythm: "w",
        start: "20170114", 
        amount:5,
    }
}

function convert(value, unit, units, targetUnit) {
    if (unit!=targetUnit)
    {
        let factor = getConversionFactor(unit, units, targetUnit)
        value = value * factor 
    }
    return value;
}

var testflows = getMergedFlows(start,end,testContract,accounts, units, contractProto)

console.log(JSON.stringify(testflows, null, 2))
function getMergedFlow(day, contracts,units, contractProto) {
    let subContracts = __.mapKeys(contracts, (value, prop) => {
        if (typeof prop === "object" ) {
            let subContract = contracts[prop]
            return getMergedFlow(day, subContract,units, contractProto)
        }
    })

    let topLevelFlow = getFlow(day, contracts, units)
    let flow = mergeContractsFlows(day, subContracts, topLevelFlow, accounts, units)
    return flow;
}

function mergeContractsFlows(day, contracts, topLevelFlow, accounts, units) {
  
    let flow = __.reduce(contracts, (flow, contract) => {
        let newFlow=getFlow(day, contract, units)
        mergeFlow(newFlow, flow, units)
    }, topLevelFlow)
    return flow;
}
function getConversionFactor(unit, units, targetUnit) {
    if (units[unit][targetUnit])
        return units[unit][targetUnit]
    else
        throw new Error("no conversion for : "+unit+" to "+targetUnit)
}
function mergeNumber(newFlow, flow, prop, units, unit) {
    let newValue = 0.0
    let wasSet=false
    if (newFlow[prop]) {
        newValue += convert(newFlow[prop], newFlow.unit, units, unit)
        wasSet= true
    }
    if (flow[prop]) {
        flow += convert(flow[prop], flow.unit, units, unit)
        wasSet= true
    }

    return wasSet?newValue:undefined;
}

function mergeFlow(newFlow, flow, units) {
    let mergedFlow = { }
    mergedFlow.unit = flow.unit || newFlow.unit
    mergedFlow.balance = mergeNumber(newFlow, flow, "balance", units, mergedFlow.unit )
    mergedFlow.balance = mergeNumber(newFlow, flow, "flow", units, mergedFlow.unit )
    return mergedFlow
}
function getFlow(day, contract, accounts, units) {
    // normalised contract
    let flow = {}
    if (contract.flows && contract.flows[day] && _.keys(accounts).indexOf(contract.acct)!=-1 ) {
        flow = clone(contract.flows[day])
    }
    return flow;
}

</script>

</head>

<body>

   <div>  hello world hi xxddxx</div>

</body>

</html>