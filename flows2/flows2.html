<!DOCTYPE html>
<html>

<head>
    <meta charset="UTF-8">
    <title>Flows2</title>
<!--     <script type="text/javascript" src="lazy.js"></script>
 -->    <!-- optional: if you want support for DOM event and AJAX-based sequences: -->
<!--     <script type="text/javascript" src="lazy.browser.js"></script>
 -->    <script type="text/javascript" src="moment-with-locales.js"></script>
 <script type="text/javascript" src="lodash.js"></script>
    <script type="text/javascript" src="flows2.js"></script>
    <script type="text/javascript">


let start =  moment('20170104' , 'YYYYMMDD' )
let end = moment('20171231' , 'YYYYMMDD' )

function getMergedFlows(start,end,contracts,accounts, units, contractProto) 
{ 
    let days=genDays(start,end)
    let normalisedContracts = normaliseContracts(contracts, days, accounts, units, contractProto)
    // => { "20170208": {  unit:"chf", flow:-1.0, balance:1.0 } }
    // each day until end date
    //  walk contracts recursively gather flows for current day: => merge per day: contract 1 and 2: add all same days together (respect currency conversion)
    let balance=0
     return _.forOwn(days, (value, day) => {
         let dayflow= getMergedFlowDay(day, normalisedContracts,accounts, units, contractProto); 
         if (dayflow.flow)
             balance += dayflow.flow
          dayflow.balance = balance
         days[day] =  dayflow
    })


}
function genDays(start, end) {
    let array=Array.apply(0, Array(Math.round(moment.duration(end.diff(start)).asDays()+1) ))
    return array.reduce((object, item, index)=>{  day=moment(start).add(index,'days'); object[day.format('YYYYMMDD')]={}; return object}, {})
}
function normaliseContracts(contracts, days, accounts, units, contractProto) {
    // go down if contract and in account generate flows
     _.forOwn(contracts, (value, prop) => {
        if (typeof value === "object" && contractProto[prop]===undefined) {
            let subContract = contracts[prop]
            subContract = inherit({}, subContract, filter(contracts, contractProto))
            //subContract.flows = genFlows(subContract, days, accounts)
            contracts[prop] = normaliseContracts(subContract,days, accounts, units, contractProto)
        }

    })
    contracts = inherit(contracts, filter(contracts, contractProto))
    normalizeDates(contracts)
    contracts.flows = genFlows(contracts, days, accounts, units)
    return contracts; 
}
function normalizeDates(contract) {
    // set start
    // norm start
    if (!contract.start)
        throw "start missing "+JSON.stringify(contract, null, 2)
    normalizeDate(contract, "start")
    normalizeDate(contract, "end")
}
function normalizeDate(contract, prop) {
    // set start
    // norm start
    let date = contract[prop]; 
    if (date) {
        let endMarker = "end"
        if (date.indexOf(endMarker)==date.length-endMarker.length) {
            if (date.length!=6+endMarker.length)
                throw "date not YYYYMM formate: "+JSON.stringify(contract, null, 2)
            let begin =  moment(date.substring(0, 6) , 'YYYYMM' )
            let end = begin.endOf('month');
            contract[prop] = end.format('YYYYMMDD') 
        }
    }
}
function findPropOnObject(prop, source) {
    for (var property in source) {
        let found=undefined
        if (prop == property) {
           found= source[property];
        } else if (typeof source[property] === "object" ) { 
            found=findPropOnObject(prop, source[property]);
        }
        if (found)
            return found
    }
    return undefined        
}
function genFlows(normalisedContract, days, accounts, units) {
    let flows = []
    if (accounts && units && !findPropOnObject(normalisedContract.acct, accounts) )
        return flows;

    // gen seq
    let sequence = getFlowSeq(normalisedContract, days)
    return _.reduce(sequence, (flows, item, index)=>{ 
        let targetUnit;
        if (accounts)
            targetUnit = findPropOnObject("unit", accounts)
        let flow = {}
        flow.flow = normalisedContract.amount
        flow.unit = normalisedContract.unit
        flows[index] = flow;
        if (targetUnit)
            flow.flow=convert(flow.flow, flow.unit, units, targetUnit) 

        ; return flows; 
    },{})
}
function getFlowSeq(normalisedContract, days) {
    let flows = {}
    let first =_.chain(days).keys().head().value()
    let last = _.findLastKey(days)
    
    
    let start = normalisedContract.start
    let current = start
    let iteration=0;
    while (current <= last) {
        iteration++
        if (current >= first)
            flows[current] = {}
        let oldcurrent=current
        current = moment(start, 'YYYYMMDD').add(iteration, normalisedContract.rythm).format('YYYYMMDD')
        if (oldcurrent==current)
         {
            throw "constant current date :"+current+" "+JSON.stringify(normalisedContract, null, 2)            
         }
    }
    return flows
}
// deep copy of undefined attributes
function inherit(source, extension, target) {
    if (!target)
        target={}
    
    return inheritClone(inheritClone(target, source ), extension)
}
// deep copy, but not overwriting dest leaves
function inheritClone(source, destination, deep) {
    for (var property in source) {
        if ( destination[property]===undefined) {
            if (typeof source[property] === "object" && deep) { 
                destination[property] = {}
                inheritClone(source[property], destination[property]);
            } else {
                destination[property] = source[property];
            }
        }
    }
    return destination
}
function filter(source, objectProto) {
    let destination={}
    for (var property in source) {
        if (objectProto[property] ===null ) { 
            destination[property] = source[property];
        }
    }
    return destination

}

let testContract = {
    acct: "zahlungs",
    unit: "chf",
    rythm: "M",
    start: "20170104", 
    amount:184,
    parking: {
        amount:150,
    },
    oil: {
        rythm: "y",
        start: "20171101", 
        amount:200,
    },
    fluid: {
        rythm: "Q",
        start: "20170114", 
        amount:20,
    },
    test: {
        rythm: "w",
        start: "20170114", 
        amount:5,
    },
    income: {
        start: "201701end", 
        amount:-350,
    },
}

function convert(value, unit, units, targetUnit) {
    if (unit!=targetUnit)
    {
        let factor = getConversionFactor(unit, units, targetUnit)
        value = value * factor 
    }
    return value;
}

var testflows = getMergedFlows(start,end,testContract,accounts, units, contractProto)

console.log(JSON.stringify(testflows, null, 2))

function getMergedFlowDay(day, contracts,accounts, units, contractProto) {
    // get flow
    let topLevelFlow = getFlow(day, contracts, accounts, units)
    // get subflow
    //   reduce sub contracts
    let mergedFlows = _.reduce(contracts, (flow, item, index) => {

    //      if subcontract
    //          new flow = getMergedFlowDay
    //          merge to subflow
    // merge flow and subflow
    // return merged flow
        if (typeof item === "object" && contractProto[index]===undefined) {
            let subContract = item
            let newFlow= getMergedFlowDay(day, subContract,accounts, units, contractProto)
            flow =  mergeFlow(newFlow, flow, units)
        }
        return flow

    }, topLevelFlow)

    return mergedFlows;
}

function getConversionFactor(unit, units, targetUnit) {
    if (units[unit][targetUnit])
        return units[unit][targetUnit]
    else
        throw new Error("no conversion for : "+unit+" to "+targetUnit)
}
function mergeNumber(newFlow, flow, prop, units, unit) {
    let newValue = 0.0
    let wasSet=false
    if (newFlow[prop]) {
        newValue += convert(newFlow[prop], newFlow.unit, units, unit)
        wasSet= true
    }
    if (flow[prop]) {
        newValue += convert(flow[prop], flow.unit, units, unit)
        wasSet= true
    }

    return wasSet?newValue:undefined;
}

function mergeFlow(newFlow, flow, units) {
    let mergedFlow = { }
    mergedFlow.unit = flow.unit || newFlow.unit
    mergedFlow.balance = mergeNumber(newFlow, flow, "balance", units, mergedFlow.unit )
    mergedFlow.flow = mergeNumber(newFlow, flow, "flow", units, mergedFlow.unit )
    return mergedFlow
}
function getFlow(day, contract, accounts, units) {
    // normalised contract
    let flow = {}
    if (contract.flows && contract.flows[day] && findPropOnObject(contract.acct, accounts) ) {
        flow = inheritClone(contract.flows[day], {})
    }
    return flow;
}

</script>

</head>

<body>

   <div>  hello world hi xxddxx</div>

</body>

</html>