<!DOCTYPE html>
<html>

<head>
    <meta charset="UTF-8">
    <title>Flows2</title>
<!--     <script type="text/javascript" src="lazy.js"></script>
 -->    <!-- optional: if you want support for DOM event and AJAX-based sequences: -->
<!--     <script type="text/javascript" src="lazy.browser.js"></script>
 -->    <script type="text/javascript" src="moment-with-locales.js"></script>
 <script type="text/javascript" src="lodash.js"></script>
    <script type="text/javascript" src="flows2.js"></script>
    <script type="text/javascript" src="jquery-3.2.1.js"></script>


    <script type="text/javascript">



// windowing: contract level, multi-contract level, multi acct level 
//  acct in flow?? yes, 
// ?? get flows per contract, per contracts

// window : start,rythm,end
// new funciton to merge flows into windows 
// get by account
//   reconcile balance in flow
// new funciton to merge accounts flows windows 
// display html, table: tr,div,hide button
//  start,end,rythm inputs 
// contract display: grey inherited items

function mergeToWindow(mergedFlows, windowSize, units, targetUnit) {
    let mergeWindowSeq = getWindowSeq(mergedFlows, windowSize)
    let flowsArray = _.flatMap(mergedFlows, (flow, day)=> {
        flow.day = day
        return flow
    });
    let flowIndex=0;
    _.each(mergeWindowSeq, (windowFlow, wind)=> {
        let windowBegin = wind.split("-")[0]
        let windowEnd = wind.split("-")[1]
        let flow = flowsArray[flowIndex]
        while (flow && flow.day >= windowBegin && flow.day <= windowEnd) {
            // merge
            mergeWindowSeq[wind] = mergeFlow(flow, mergeWindowSeq[wind] , units, targetUnit,true)
            flowIndex++
            flow = flowsArray[flowIndex]
        }
    });
    return mergeWindowSeq;
}
function getWindowSeq(flows, rythm) {
    let first =_.chain(flows).keys().head().value()
    let last = _.findLastKey(flows)
    return getWindowedSeq(first, last, rythm);
}

function getWindowedSeq(first, last, rythm) {

    let windowFlows = {}

    let start = first
    let current = start
    let next; 

    // current and next: last-next-1-rythm
    
    while (current <= last) {
        next = moment(current, 'YYYYMMDD').add(1, rythm).format('YYYYMMDD')
        nextminusone = moment(next, 'YYYYMMDD').add(-1, "d").format('YYYYMMDD')
        windowFlows[current+"-"+nextminusone+"-"+rythm] = {}

        if (next==current)
        {
            throw "constant current date :"+current+" , rythm: "+rythm            
        }
        current = next 
    }
    return windowFlows
}
function getAllAccountNames(normalizedAcccounts) {
    let accts = []
    function gatherAccts(account, name) {
        if (account && account.balances)
            accts.push(name)
    }
    walkPojo(normalizedAcccounts, gatherAccts)

    return accts
}
function getMergedFlowsAllAccounts(days,normalisedContracts,normalizedAcccounts, targetAccounts, units, contractProto, targetUnit) 
{ 
    let dayFlowAllAccounts= {}
    if (!targetAccounts) {
        targetAccounts = getAllAccountNames(normalizedAcccounts)
    }
    _.each(targetAccounts, (account) => {
        let balance=0
        let balances =  findPropOnObject("balances", findPropOnObject(account, normalizedAcccounts));
        let accountUnit =  findPropOnObject("unit", findPropOnObject(account, normalizedAcccounts));
        let mergedFlows = {}
        _.forOwn(days, (value, day) => {
             let dayflow= getMergedFlowDayAllContracts(day, normalisedContracts,account, units, contractProto, accountUnit); 

             dayflow.accounts=new Set().add(account)
                          
             if (dayflow.flow)
                 balance += dayflow.flow
             
             if (dayflow.flow===undefined) 
                 dayflow.flow = 0.0
              
              balance = Math.round(balance*100)/100   
              if (balances && balances[day]) 
              {
                  dayflow.oldBalance = balance 
                  balance = balances[day]
              }   
              dayflow.balance = balance
              dayFlowAllAccounts[day] = mergeFlow(dayflow, dayFlowAllAccounts[day] , units, accountUnit)
        }) 

    })
    return dayFlowAllAccounts;

}
function acctsToArray(accounts) {
    let accts = []
    function extractAcct(account, key) {
        if (!account.unit ||account.rythm || !account.balances)
            return 
        acct = {}
        acct[key] = account 
        accts.push(acct)        
    }
    walkPojo(accounts, extractAcct)

    return accts 
}
function extractAccount(account, accounts) {let acct={}; acct[account] = findPropOnObject(account, accounts); return acct; };
function genDays(start, end) {
    let array=Array.apply(0, Array(Math.round(moment.duration(end.diff(start)).asDays()+1) ))
    return array.reduce((object, item, index)=>{  day=moment(start).add(index,'days'); object[day.format('YYYYMMDD')]={}; return object}, {})
}

// inherit deep 
// walk apply normalizedates
// walk apply gen flows

function normaliseContracts(contracts, days, contractProto) {
        contracts = inherit(contracts, {} , contractProto, true)
        walkPojo(contracts, normalizeDates)
        walkPojo(contracts, normalizeAmount)
        walkPojo(contracts, contracts=>genFlows(contracts, days))
        return contracts
}
function genFlows(normalisedContract, days) {

    if (!normalisedContract.amount || !normalisedContract.unit || !normalisedContract.start)
        return 
    let flows = {}

    // gen seq
    let sequence = getFlowSeq(normalisedContract, days)

    _.reduce(sequence, (flows, item, index)=>{ 
        let flow = { accounts:new Set()}
        flow.flow = normalisedContract.amount
        flow.unit = normalisedContract.unit
        flow.accounts = new Set().add(normalisedContract.acct)
        flows[index] = flow;

        return flows; 
    },flows)

    normalisedContract.flows = flows;

}
function getMergedFlowDayAllContracts(day, contracts,account, units, contractProto, targetUnit) {
    // get flow
    let topLevelFlow = getFlow(day, contracts, account, units, targetUnit)

    let mergedFlows = _.reduce(contracts, (flow, item, index) => {

        if (typeof item === "object" && contractProto[index]===undefined) {
            let subContract = item
            let newFlow= getMergedFlowDayAllContracts(day, subContract,account, units, contractProto, targetUnit)
            flow =  mergeFlow(newFlow, flow, units, targetUnit)
        }
        return flow

    }, topLevelFlow)

    return mergedFlows;
}

function mergeFlow(newFlow, flow, units, targetUnit, aggregate) {
    let mergedFlow = { }
    mergedFlow.unit = targetUnit || (flow&&flow.unit) || (newFlow&&newFlow.unit)
    mergedFlow.balance = mergeNumber(newFlow, flow, "balance", units, mergedFlow.unit, aggregate)
    mergedFlow.flow = mergeNumber(newFlow, flow, "flow", units, mergedFlow.unit )
    if (newFlow&&(newFlow.oldBalance!==undefined))
        mergedFlow.oldBalance = newFlow.oldBalance
    else if (flow&&(flow.oldBalance!==undefined)) 
        mergedFlow.oldBalance = flow.oldBalance
    
    mergedFlow.accounts = mergeSets(newFlow&&newFlow.accounts, flow&&flow.accounts)

    return mergedFlow
}

function mergeSets(s1, s2)
{   
    let newSet = new Set()
    if (s1)
        s1.forEach( item=> {
            newSet.add(item)
            })
    if (s2 )
        s2.forEach(item=>{
            newSet.add(item)
            })
    if ((s2 && s2.size || s1 && s1.size )&& !newSet.size)        
        console.log("opss")
    return newSet
}

function getFlow(day, normalisedContract, account, units, targetUnit) {
    // normalised contract
    let flow = {}

    if (normalisedContract.flows && normalisedContract.flows[day] && normalisedContract.acct==account ) {
        
        flow = normalisedContract.flows[day]

        flow.flow = normalisedContract.amount
        flow.unit = normalisedContract.unit
 
        if (targetUnit != flow.unit) {
            flow.flow=convert(flow.flow, flow.unit, units, targetUnit) 
            
        }
    }
    flow.accounts = new Set().add(account)
    flow.unit = targetUnit
    if (flow.flow===undefined)
        flow.flow = 0.0
    return flow;
}
function walkPojo(source, iterator, key, level, path)
{
    if (level===undefined)
        level = 0
    if (path===undefined)
        path = ""
    iterator(source, key, level, path)
    if (key===undefined)
        key = ""
    for (var property in source) {
        if (typeof source[property] === "object") { 
            walkPojo(source[property], iterator, property, level+1, path+"."+key)   
        }
    } 

}
function normalizeAmount(contract) {
    // set start
    // norm start
    if (!contract.amount)
        return 
    contract.amount = -contract.amount
}
function normalizeDates(contract) {
    // set start
    // norm start
    if (!contract.start)
        return 
    normalizeDate(contract, "start")
    normalizeDate(contract, "end")
}
function normalizeDate(contract, prop) {
    // set start
    // norm start
    let date = contract[prop]; 
    if (date) {
        let endMarker = "end"
        if (date.indexOf(endMarker)==date.length-endMarker.length) {
            if (date.length!=6+endMarker.length)
                throw "date not YYYYMM formate: "+JSON.stringify(contract, null, 2)
            let begin =  moment(date.substring(0, 6) , 'YYYYMM' )
            let end = begin.endOf('month');
            contract[prop] = end.format('YYYYMMDD') 
        }
    }
}

function findPropOnObject(prop, source) {
    for (var property in source) {
        let found=undefined
        if (prop == property) {
           found= source[property];
        } else if (typeof source[property] === "object" ) { 
            found=findPropOnObject(prop, source[property]);
        }
        if (found)
            return found
    }
    return undefined        
}
function getFlowSeq(normalisedContract, days) {
    let flows = {}
    let first =_.chain(days).keys().head().value()
    let last = _.findLastKey(days)
    
    
    let start = normalisedContract.start
    let current = start
    let iteration=0;
    while (current <= last) {
        iteration++
        if (current >= first)
            flows[current] = {}
        let oldcurrent=current
        current = moment(start, 'YYYYMMDD').add(iteration, normalisedContract.rythm).format('YYYYMMDD')
        if (oldcurrent==current)
         {
            throw "constant current date :"+current+" "+JSON.stringify(normalisedContract, null, 2)            
         }
    }
    return flows
}
// deep copy of undefined attributes
function inherit(source, parent , prototype, deep) {
    // filter parent 
    let target  = {}

    // copy source props
    //   if prop in prototype: deep copy/clone 
    for (var prop in source) {
        if ( prototype[prop] !== undefined ) {
             if (typeof source[prop] == "object"  ) {
                target[prop] = clone(source[prop], true)
            } else {
                target[prop] = source[prop]                
            }
        }
    }

    // inheit from parent
    for (var prop in parent) {
        if (prototype[prop] === null &&  target[prop]===undefined && parent[prop]!== undefined )
            target[prop] = parent[prop]
    }

    for (var prop in source) {
        if (prototype[prop] === undefined &&  typeof source[prop] == "object"  ) {
            if (deep)
                target[prop] = inherit(source[prop], target, prototype, deep)
            else 
                target[prop] = source[prop]
        }
    }

    return target
}

// deep copy, but not overwriting dest leaves
function clone(source, deep) {
    let destination = {}
    for (var property in source) {
        if (typeof source[property] === "object" && deep) { 
            destination[property] = {}
            clone(source[property], destination[property]);
        } else {
            destination[property] = source[property];
        }
       }
    return destination
}


function convert(value, unit, units, targetUnit) {
    if (unit!=targetUnit)
    {
        let factor = getConversionFactor(unit, units, targetUnit)
        value = value * factor 
        value = Math.round(value*100)/100
    }
    return value;
}

function getConversionFactor(unit, units, targetUnit) {
    if (units[unit][targetUnit])
        return units[unit][targetUnit]
    else
        throw new Error("no conversion for : "+unit+" to "+targetUnit)
}
function mergeNumber(newFlow, flow, prop, units, unit, aggregate) {
    let newValue = 0.0
    let wasSet=false
    if (flow&&flow[prop]) {
        if (aggregate)
            newValue = convert(flow[prop], flow.unit, units, unit)
        else
            newValue += convert(flow[prop], flow.unit, units, unit)
        wasSet= true
    }
    if (newFlow&&newFlow[prop]) {
        if (aggregate)
            newValue = convert(newFlow[prop], newFlow.unit, units, unit)
        else
            newValue += convert(newFlow[prop], newFlow.unit, units, unit)
        wasSet= true
    }

    newValue = Math.round(newValue*100)/100

    return newValue;
}

Set.prototype.toJSON = function toJSON() {
  return [...Set.prototype.values.call(this)];
}

const contractProto = {
    start:null, duration:null,end:null, amount:null, acct:null, rythm:null, flows : [], unit: null
}
const prototypeAccount = {
    unit:null, balances: []
}

const accounts = {
    post : {
        unit:"chf" 
        ,zahlungs : { 
            balances :{'20170104' : 1000, '20171231' : 600, },
         },
        spar : { 
            start: 20170101, rythm: "M", amount: 1000
        }
        ,usd : { unit:"usd", balances :{'20170101' : 100 }}
        ,eur : { unit:"eur",  balances :{'20170101' : 10 }}
        ,spar : { }
        ,"3a" : { }
     }
    ,tnb : {
        unit:"usd" 
        ,checking: {
            balances :{'20170101' : 2000 }
        }
        ,savings: {}
     }
}

const units = {
    chf: {eur:1/1.2, usd:1.1}
    ,eur: {chf:1.2, usd:1.1}
    ,usd: {eur:1/1.1, chf:1/1.1}
}

// Key  Shorthand
// years    y
// quarters Q
// months   M
// weeks    w
// days d
// hours    h
// minutes  m
// seconds  s
// milliseconds ms
let testContract = {
    acct: "zahlungs",
    unit: "chf",
   rythm: "M",
    start: "20170104", 
    amount:184,
    parking: {
        amount:150,
    },
    oil: {
        rythm: "y",
        start: "20171101", 
        amount:200,
    },
    fluid: {
        rythm: "Q",
        start: "20170114", 
        amount:20,
    },
    test: {
        rythm: "w",
        start: "20170114", 
        amount:5,
        testsub: {
            rythm: "w",
            start: "20170114", 
            amount:5,
        },
    },
    income: {
        start: "201701end", 
        amount:-350,
        unit:"eur"
    },
    income2: {
        acct: "checking",
        start: "201701end", 
        amount:-300,
        unit:"usd"
    },
}

let start =  moment('20170101' , 'YYYYMMDD' )
let end = moment('20171231' , 'YYYYMMDD' )
let windowSize= "M"

//let targetAccounts = ["zahlungs", "checking", "spar"]
let targetCurrency = "chf"

function normaliseAccounts(accounts,days, prototypeAccount) {
    let normalizedAcccounts = inherit(accounts,{}, prototypeAccount, true);
    // bring last balance before start day forward, if start day does not have balance ??
    // go down balances until >= start day, if start day not defined and there is one before copy it in on start day

    function bringFowardOldBalance() {

    }
    walkPojo(normalizedAcccounts, bringFowardOldBalance)
    return normalizedAcccounts
}

function refreshWindows() {
    let days=genDays(start,end)
    let normalisedContracts = normaliseContracts(testContract, days, contractProto)

    let normalizedAcccounts = normaliseAccounts(accounts,days, prototypeAccount) 

    //let targetAccounts = ["zahlungs"]
    //let accountExtract = extractAccount(account, normalizedAcccounts);

    let $tableEnd=createTable(getWindowedSeq(start.format('YYYYMMDD'), end.format('YYYYMMDD'), windowSize));

    walkPojo(normalisedContracts, listContracts, "test")

    walkPojo(normalizedAcccounts, listAccounts)

    // grand total
    let mergedFlows = getMergedFlowsAllAccounts(days, normalisedContracts, normalizedAcccounts, undefined, units, contractProto, targetCurrency)

    let windowedFlows = mergeToWindow(mergedFlows , windowSize)

    appendFooter($tableEnd, {unit:targetCurrency}, windowedFlows, "Totals")

    function listAccounts(targetAccount, targetAccountName)    
    {
       if (!targetAccount.balances) 
        return 
       // total each account
        let mergedFlows = getMergedFlowsAllAccounts(days, normalisedContracts, normalizedAcccounts, [targetAccountName], units, contractProto, targetCurrency)

        let windowedFlows = mergeToWindow(mergedFlows , windowSize)

        console.log(JSON.stringify(windowedFlows, null, 2))
        appendFooter($tableEnd, targetAccount, windowedFlows, targetAccountName)
    }
    // walk contracts
    function listContracts(targetContract, targetContractName, level, path )    
    {
       if (!targetContract.amount) 
        return 

        let mergedFlows = getMergedFlowsAllAccounts(days, targetContract, normalizedAcccounts, undefined, units, contractProto, targetContract.unit)

        console.log(JSON.stringify(mergedFlows, null, 2))
        let windowedFlows = mergeToWindow(mergedFlows , windowSize)

        console.log(JSON.stringify(windowedFlows, null, 2))
        appendRow($tableEnd, targetContract, windowedFlows, targetContractName, level, path)
    }

    function createTable(windowedSeq){
        $('#flows').empty();

        $('<div>').text("window:").append($input=$('<input>').val(windowSize).on('blur', (e)=>{
            windowSize=e.target.value; refreshWindows()
            }))
                .appendTo($('#flows'))

        $('<div>').text("start:").append($input=$('<input>').val(start.format('YYYYMMDD')).on('blur', (e)=>{
            start=moment(e.target.value,'YYYYMMDD'); refreshWindows()
            }))
                .appendTo($('#flows'))

        $('<div>').text("end:").append($input=$('<input>').val(end.format('YYYYMMDD')).on('blur', (e)=>{
            end=moment(e.target.value,'YYYYMMDD'); refreshWindows()
            }))
                .appendTo($('#flows'))

        // $('<div>').text("targetAccounts:"+targetAccounts)
        //         .appendTo($('#flows'))

        $('<div>').text("targetCurrency:").append($('<input>').val(targetCurrency).on('blur', (e)=>{
            targetCurrency=e.target.value; refreshWindows()
            }))
                .appendTo($('#flows'))

        let $table = $('<table>')
        $table.css("border","1px solid #000");
        let $header= $('<tr>').appendTo(
            $table
                .appendTo($('#flows'))
            )

        $header.append($('<td>').text("name")
          .css("border","1px solid #000"));

        _.each(contractProto, (value, prop)=>{
            if (value==null)
                $header.append($('<td>').text(prop)
                  .css("border","1px solid #000"));

                })
        _.each(windowedSeq, (wind, day)=>{
            $header.append($('<td>').text(day.split('-')[0])
              .css("border","1px solid #000"));
            })

        return $table
    }
    
    function appendRow($appendPoint, targetContract, windowedFlows, contractName, level, path) {

        function toggleShow(e) {
            let $tr = $(this)
            let parentPath = $tr.data("path")
            $('tr').each((index, tr)=>{
                let $tr = $(tr)
                let myPath = $tr.data("path")
                if (myPath && myPath.startsWith(parentPath+"." )) {
                    $tr.show()
                }
            })
            $tr
            .off("click", toggleShow)
            .on("click", toggleHide)
            
        }
        function toggleHide(e) {
            let $tr = $(this)
            let parentPath = $tr.data("path")
            $('tr').each((index, tr)=>{
                let $tr = $(tr)
                let myPath = $tr.data("path")
                if (myPath && myPath.startsWith(parentPath+"." )) {
                    $tr.hide()
                }
            })
            $tr
            .off("click", toggleHide)
            .on("click", toggleShow)
            
        }
        let $tr = $('<tr>')
            .data("path", path+"."+(contractName?contractName:""))
            .appendTo($appendPoint)
            .on("click", toggleHide)

        $tr.append($('<td>')
            .text((contractName?contractName:""))
          .css("padding-left", ' '+(level*10)+"px")
          .css("border","1px solid #000")
          )
        ;

        _.each(contractProto, (value, prop)=>{
            if (value==null)
                $tr.append($('<td>').text(targetContract[prop])
                  .css("border","1px solid #000")
                  .css("padding-left", ' '+(level*10)+"px")
                  );

                })

        _.each(windowedFlows, (wind, day)=>{
            $tr.append($('<td>').text(wind.flow)
              .css("border","1px solid #000")
              .css("padding-left", ' '+(level*10)+"px")
              );
            })

    }
    function appendFooter($appendPoint, targetContract, windowedFlows, contractName) {
        
        let $tr = $('<tr>').appendTo($appendPoint)

        $tr.append($('<td>').text(contractName)
          .css("border","1px solid #000"));
        _.each(contractProto, (value, prop)=>{
            if (value==null)
                $tr.append($('<td>').text(targetContract[prop])
                  .css("border","1px solid #000"));

                })

        _.each(windowedFlows, (wind, day)=>{
            let $td ;
            $tr.append(
                $('<td>')
                .append($('<span>').text(wind.flow))
                .append($bal=$('<span>').text(" ("+wind.balance+")"))
                .css("border","1px solid #000")
              );

            if (wind.oldBalance!==undefined) {
                $bal.css("color","lightgreen") 
                $bal.css("font-weight","bold") 
            }
        })
    
    }

}

$(refreshWindows)
</script>

</head>

<body>

   <div id="flows">  </div>

</body>

</html>