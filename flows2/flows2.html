<!DOCTYPE html>
<html>

<head>
    <meta charset="UTF-8">
    <title>Flows2</title>
<!--     <script type="text/javascript" src="lazy.js"></script>
 -->    <!-- optional: if you want support for DOM event and AJAX-based sequences: -->
<!--     <script type="text/javascript" src="lazy.browser.js"></script>
 -->    <script type="text/javascript" src="moment-with-locales.js"></script>
 <script type="text/javascript" src="lodash.js"></script>
    <script type="text/javascript" src="flows2.js"></script>
    <script type="text/javascript">


let start =  moment('20170104' , 'YYYYMMDD' )
let end = moment('20171231' , 'YYYYMMDD' )

// get by account
//   reconcile balance in flow
// new funciton to merge flows into windows 
// new funciton to merge accounts flows windows 
 
function getMergedFlows(start,end,contracts,accounts, units, contractProto, targetUnit) 
{ 
    let days=genDays(start,end)
    let normalisedContracts = normaliseContracts(contracts, days, contractProto)

    let balance=0
     return _.forOwn(days, (value, day) => {
         let dayflow= getMergedFlowDay(day, normalisedContracts,accounts, units, contractProto, targetUnit); 

         if (dayflow.flow)
             balance += dayflow.flow
          dayflow.balance = Math.round(balance*100)/100

         days[day] =  dayflow
    })


}
function genDays(start, end) {
    let array=Array.apply(0, Array(Math.round(moment.duration(end.diff(start)).asDays()+1) ))
    return array.reduce((object, item, index)=>{  day=moment(start).add(index,'days'); object[day.format('YYYYMMDD')]={}; return object}, {})
}

// inherit deep 
// walk apply normalizedates
// walk apply gen flows

function normaliseContracts(contracts, days, contractProto) {
        contracts = inherit(contracts, {} , contractProto, true)
        walkPojo(contracts, normalizeDates)
        walkPojo(contracts, contracts=>genFlows(contracts, days))
        return contracts
}

function walkPojo(source, iterator)
{
    iterator(source)
    for (var property in source) {
        if (typeof source[property] === "object") { 
            walkPojo(source[property], iterator)   
        }
    } 

}
function normalizeDates(contract) {
    // set start
    // norm start
    if (!contract.start)
        throw "start missing "+JSON.stringify(contract, null, 2)
    normalizeDate(contract, "start")
    normalizeDate(contract, "end")
}
function normalizeDate(contract, prop) {
    // set start
    // norm start
    let date = contract[prop]; 
    if (date) {
        let endMarker = "end"
        if (date.indexOf(endMarker)==date.length-endMarker.length) {
            if (date.length!=6+endMarker.length)
                throw "date not YYYYMM formate: "+JSON.stringify(contract, null, 2)
            let begin =  moment(date.substring(0, 6) , 'YYYYMM' )
            let end = begin.endOf('month');
            contract[prop] = end.format('YYYYMMDD') 
        }
    }
}
function findPropOnObject(prop, source) {
    for (var property in source) {
        let found=undefined
        if (prop == property) {
           found= source[property];
        } else if (typeof source[property] === "object" ) { 
            found=findPropOnObject(prop, source[property]);
        }
        if (found)
            return found
    }
    return undefined        
}
function genFlows(normalisedContract, days) {

    if (!normalisedContract.amount || !normalisedContract.unit || !normalisedContract.start)
        return 
    let flows = {}

    // gen seq
    let sequence = getFlowSeq(normalisedContract, days)

    _.reduce(sequence, (flows, item, index)=>{ 
        let flow = {}
        flow.flow = normalisedContract.amount
        flow.unit = normalisedContract.unit
        flows[index] = flow;

        ; return flows; 
    },flows)
    console.log("hii")
    normalisedContract.flows = flows;

}
function getFlowSeq(normalisedContract, days) {
    let flows = {}
    let first =_.chain(days).keys().head().value()
    let last = _.findLastKey(days)
    
    
    let start = normalisedContract.start
    let current = start
    let iteration=0;
    while (current <= last) {
        iteration++
        if (current >= first)
            flows[current] = {}
        let oldcurrent=current
        current = moment(start, 'YYYYMMDD').add(iteration, normalisedContract.rythm).format('YYYYMMDD')
        if (oldcurrent==current)
         {
            throw "constant current date :"+current+" "+JSON.stringify(normalisedContract, null, 2)            
         }
    }
    return flows
}
// deep copy of undefined attributes
function inherit(source, parent , prototype, deep) {
    // filter parent 
    let target  = {}

    // copy source props
    //   if prop in prototype: deep copy/clone 
    for (var prop in source) {
        if ( prototype[prop] === null )
            target[prop] = source[prop]
    }

    // inheit from parent
    for (var prop in parent) {
        if (prototype[prop] === null &&  target[prop]===undefined && parent[prop]!== undefined )
            target[prop] = parent[prop]
    }

    for (var prop in source) {
        if (prototype[prop] === undefined &&  typeof source[prop] == "object"  ) {
            if (deep)
                target[prop] = inherit(source[prop], target, prototype, deep)
            else 
                target[prop] = source[prop]
        }
    }

    return target
}

// deep copy, but not overwriting dest leaves
function clone(source, deep) {
    let destination = {}
    for (var property in source) {
        if (typeof source[property] === "object" && deep) { 
            destination[property] = {}
            inheritClone(source[property], destination[property]);
        } else {
            destination[property] = source[property];
        }
       }
    return destination
}

let testContract = {
    acct: "zahlungs",
    unit: "chf",
    rythm: "M",
    start: "20170104", 
    amount:184,
    parking: {
        amount:150,
    },
    oil: {
        rythm: "y",
        start: "20171101", 
        amount:200,
    },
    fluid: {
        rythm: "Q",
        start: "20170114", 
        amount:20,
    },
    test: {
        rythm: "w",
        start: "20170114", 
        amount:5,
    },
    income: {
        start: "201701end", 
        amount:-350,
        unit:"eur"
    },
    income2: {
        acct: "checking",
        start: "201701end", 
        amount:-300,
        unit:"usd"
    },
}

function convert(value, unit, units, targetUnit) {
    if (unit!=targetUnit)
    {
        let factor = getConversionFactor(unit, units, targetUnit)
        value = value * factor 
        value = Math.round(value*100)/100
    }
    return value;
}
var normalizedAcccounts = inherit(accounts,{}, prototypeAccount, true);
// normalizedAcccounts.post.zahlungs
var testflows = getMergedFlows(start,end,testContract, {zahlungs: normalizedAcccounts.post.zahlungs}, units, contractProto, "chf")

console.log(JSON.stringify(testflows, null, 2))

function getMergedFlowDay(day, contracts,accounts, units, contractProto, targetUnit) {
    // get flow
    let topLevelFlow = getFlow(day, contracts, accounts, units, targetUnit)
    // get subflow
    //   reduce sub contracts
    let mergedFlows = _.reduce(contracts, (flow, item, index) => {

        if (typeof item === "object" && contractProto[index]===undefined) {
            let subContract = item
            let newFlow= getMergedFlowDay(day, subContract,accounts, units, contractProto, targetUnit)
            flow =  mergeFlow(newFlow, flow, units)
        }
        return flow

    }, topLevelFlow)

    return mergedFlows;
}

function getConversionFactor(unit, units, targetUnit) {
    if (units[unit][targetUnit])
        return units[unit][targetUnit]
    else
        throw new Error("no conversion for : "+unit+" to "+targetUnit)
}
function mergeNumber(newFlow, flow, prop, units, unit) {
    let newValue = 0.0
    let wasSet=false
    if (newFlow[prop]) {
        newValue += convert(newFlow[prop], newFlow.unit, units, unit)
        wasSet= true
    }
    if (flow[prop]) {
        newValue += convert(flow[prop], flow.unit, units, unit)
        wasSet= true
    }

    return wasSet?newValue:undefined;
}

function mergeFlow(newFlow, flow, units) {
    let mergedFlow = { }
    mergedFlow.unit = flow.unit || newFlow.unit
    mergedFlow.balance = mergeNumber(newFlow, flow, "balance", units, mergedFlow.unit )
    mergedFlow.flow = mergeNumber(newFlow, flow, "flow", units, mergedFlow.unit )
    return mergedFlow
}
function getFlow(day, normalisedContract, accounts, units, targetUnit) {
    // normalised contract
    let flow = {}

    if (normalisedContract.flows && normalisedContract.flows[day] && findPropOnObject(normalisedContract.acct, accounts) ) {
        
        flow = normalisedContract.flows[day]
        // convert?

        flow.flow = normalisedContract.amount
        flow.unit = normalisedContract.unit
 
        if (targetUnit != flow.unit) {
            flow.flow=convert(flow.flow, flow.unit, units, targetUnit) 
            flow.unit = targetUnit
        }
    }
    return flow;
}




</script>

</head>

<body>

   <div>  hello world hi xxddxx</div>

</body>

</html>