<!DOCTYPE html>
<html>

<head>
    <meta charset="UTF-8">
    <title>Flows2</title>
<!--     <script type="text/javascript" src="lazy.js"></script>
 -->    <!-- optional: if you want support for DOM event and AJAX-based sequences: -->
<!--     <script type="text/javascript" src="lazy.browser.js"></script>
 -->    <script type="text/javascript" src="moment-with-locales.js"></script>
 <script type="text/javascript" src="lodash.js"></script>
    <script type="text/javascript" src="flows2.js"></script>
    <script type="text/javascript">



// windowing: contract level, multi-contract level, multi acct level 
//  acct in flow?? yes, 
// ?? get flows per contract, per contracts

// window : start,rythm,end
// new funciton to merge flows into windows 
// get by account
//   reconcile balance in flow
// new funciton to merge accounts flows windows 
// display html, table: tr,div,hide button
//  start,end,rythm inputs 
// contract display: grey inherited items

function mergeToWindow(mergedFlows, windowSize, units, targetUnit) {
    let mergeWindowSeq = getWindowSeq(mergedFlows, windowSize)
    let flowsArray = _.flatMap(mergedFlows, (flow, day)=> {
        flow.day = day
        return flow
    });
    let flowIndex=0;
    _.each(mergeWindowSeq, (windowFlow, wind)=> {
        let windowBegin = wind.split("-")[0]
        let windowEnd = wind.split("-")[1]
        let flow = flowsArray[flowIndex]
        while (flow && flow.day >= windowBegin && flow.day <= windowEnd) {
            // merge
            mergeWindowSeq[wind] = mergeFlow(flow, mergeWindowSeq[wind] , units, targetUnit,true)
            flowIndex++
            flow = flowsArray[flowIndex]
        }
    });
    return mergeWindowSeq;
}
function getWindowSeq(flows, rythm) {
    let windowFlows = {}
    let first =_.chain(flows).keys().head().value()
    let last = _.findLastKey(flows)
    
    
    let start = first
    let current = start
    let next; 

    // current and next: last-next-1-rythm
    
    while (current <= last) {
        next = moment(current, 'YYYYMMDD').add(1, rythm).format('YYYYMMDD')
        nextminusone = moment(next, 'YYYYMMDD').add(-1, "d").format('YYYYMMDD')
        windowFlows[current+"-"+nextminusone+"-"+rythm] = {}

        if (next==current)
        {
            throw "constant current date :"+current+" , rythm: "+rythm            
        }
        current = next 
    }
    return windowFlows
}

function getMergedFlowsAllAccounts(days,normalisedContracts,normalizedAcccounts, targetAccounts, units, contractProto, targetUnit) 
{ 
    let dayFlowAllAccounts= {}
    _.each(targetAccounts, (account) => {
        let balance=0
        let balances =  findPropOnObject("balances", findPropOnObject(account, normalizedAcccounts));
        let mergedFlows = {}
        _.forOwn(days, (value, day) => {
             let dayflow= getMergedFlowDayAllContracts(day, normalisedContracts,account, units, contractProto, targetUnit); 

             dayflow.accounts=new Set().add(account)
                          
             if (dayflow.flow)
                 balance += dayflow.flow
              
              balance = Math.round(balance*100)/100   
              if (balances && balances[day]) 
              {
                  dayflow.oldBalance = balance 
                  balance = balances[day]
              }   
              dayflow.balance = balance
              dayFlowAllAccounts[day] = mergeFlow(dayflow, dayFlowAllAccounts[day] , units, targetUnit)
        }) 

    })
    return dayFlowAllAccounts;

}
function acctsToArray(accounts) {
    let accts = []
    function extractAcct(account, key) {
        if (!account.unit ||account.rythm || !account.balances)
            return 
        acct = {}
        acct[key] = account 
        accts.push(acct)        
    }
    walkPojo(accounts, extractAcct)

    return accts 
}
function extractAccount(account, accounts) {let acct={}; acct[account] = findPropOnObject(account, accounts); return acct; };
function genDays(start, end) {
    let array=Array.apply(0, Array(Math.round(moment.duration(end.diff(start)).asDays()+1) ))
    return array.reduce((object, item, index)=>{  day=moment(start).add(index,'days'); object[day.format('YYYYMMDD')]={}; return object}, {})
}

// inherit deep 
// walk apply normalizedates
// walk apply gen flows

function normaliseContracts(contracts, days, contractProto) {
        contracts = inherit(contracts, {} , contractProto, true)
        walkPojo(contracts, normalizeDates)
        walkPojo(contracts, contracts=>genFlows(contracts, days))
        return contracts
}
function genFlows(normalisedContract, days) {

    if (!normalisedContract.amount || !normalisedContract.unit || !normalisedContract.start)
        return 
    let flows = {}

    // gen seq
    let sequence = getFlowSeq(normalisedContract, days)

    _.reduce(sequence, (flows, item, index)=>{ 
        let flow = { accounts:new Set()}
        flow.flow = normalisedContract.amount
        flow.unit = normalisedContract.unit
        flow.accounts = new Set().add(normalisedContract.acct)
        flows[index] = flow;

        return flows; 
    },flows)

    normalisedContract.flows = flows;

}
function getMergedFlowDayAllContracts(day, contracts,account, units, contractProto, targetUnit) {
    // get flow
    let topLevelFlow = getFlow(day, contracts, account, units, targetUnit)

    let mergedFlows = _.reduce(contracts, (flow, item, index) => {

        if (typeof item === "object" && contractProto[index]===undefined) {
            let subContract = item
            let newFlow= getMergedFlowDayAllContracts(day, subContract,account, units, contractProto, targetUnit)
            flow =  mergeFlow(newFlow, flow, units, targetUnit)
        }
        return flow

    }, topLevelFlow)

    return mergedFlows;
}

function mergeFlow(newFlow, flow, units, targetUnit, aggregate) {
    let mergedFlow = { }
    mergedFlow.unit = targetUnit || (flow&&flow.unit) || (newFlow&&newFlow.unit)
    mergedFlow.balance = mergeNumber(newFlow, flow, "balance", units, mergedFlow.unit, aggregate)
    mergedFlow.flow = mergeNumber(newFlow, flow, "flow", units, mergedFlow.unit )
    
    mergedFlow.accounts = mergeSets(newFlow&&newFlow.accounts, flow&&flow.accounts)

    return mergedFlow
}

function mergeSets(s1, s2)
{   
    let newSet = new Set()
    if (s1)
        s1.forEach( item=> {
            newSet.add(item)
            })
    if (s2 )
        s2.forEach(item=>{
            newSet.add(item)
            })
    if ((s2 && s2.size || s1 && s1.size )&& !newSet.size)        
        console.log("opss")
    return newSet
}

function getFlow(day, normalisedContract, account, units, targetUnit) {
    // normalised contract
    let flow = {}

    if (normalisedContract.flows && normalisedContract.flows[day] && normalisedContract.acct==account ) {
        
        flow = normalisedContract.flows[day]

        flow.flow = normalisedContract.amount
        flow.unit = normalisedContract.unit
        flow.accounts = new Set().add(account)
 
        if (targetUnit != flow.unit) {
            flow.flow=convert(flow.flow, flow.unit, units, targetUnit) 
            flow.unit = targetUnit
        }
    }
    return flow;
}
function walkPojo(source, iterator, key)
{
    iterator(source, key)
    for (var property in source) {
        if (typeof source[property] === "object") { 
            walkPojo(source[property], iterator, property)   
        }
    } 

}
function normalizeDates(contract) {
    // set start
    // norm start
    if (!contract.start)
        return 
    normalizeDate(contract, "start")
    normalizeDate(contract, "end")
}
function normalizeDate(contract, prop) {
    // set start
    // norm start
    let date = contract[prop]; 
    if (date) {
        let endMarker = "end"
        if (date.indexOf(endMarker)==date.length-endMarker.length) {
            if (date.length!=6+endMarker.length)
                throw "date not YYYYMM formate: "+JSON.stringify(contract, null, 2)
            let begin =  moment(date.substring(0, 6) , 'YYYYMM' )
            let end = begin.endOf('month');
            contract[prop] = end.format('YYYYMMDD') 
        }
    }
}

function findPropOnObject(prop, source) {
    for (var property in source) {
        let found=undefined
        if (prop == property) {
           found= source[property];
        } else if (typeof source[property] === "object" ) { 
            found=findPropOnObject(prop, source[property]);
        }
        if (found)
            return found
    }
    return undefined        
}
function getFlowSeq(normalisedContract, days) {
    let flows = {}
    let first =_.chain(days).keys().head().value()
    let last = _.findLastKey(days)
    
    
    let start = normalisedContract.start
    let current = start
    let iteration=0;
    while (current <= last) {
        iteration++
        if (current >= first)
            flows[current] = {}
        let oldcurrent=current
        current = moment(start, 'YYYYMMDD').add(iteration, normalisedContract.rythm).format('YYYYMMDD')
        if (oldcurrent==current)
         {
            throw "constant current date :"+current+" "+JSON.stringify(normalisedContract, null, 2)            
         }
    }
    return flows
}
// deep copy of undefined attributes
function inherit(source, parent , prototype, deep) {
    // filter parent 
    let target  = {}

    // copy source props
    //   if prop in prototype: deep copy/clone 
    for (var prop in source) {
        if ( prototype[prop] !== undefined ) {
             if (typeof source[prop] == "object"  ) {
                target[prop] = clone(source[prop], true)
            } else {
                target[prop] = source[prop]                
            }
        }
    }

    // inheit from parent
    for (var prop in parent) {
        if (prototype[prop] === null &&  target[prop]===undefined && parent[prop]!== undefined )
            target[prop] = parent[prop]
    }

    for (var prop in source) {
        if (prototype[prop] === undefined &&  typeof source[prop] == "object"  ) {
            if (deep)
                target[prop] = inherit(source[prop], target, prototype, deep)
            else 
                target[prop] = source[prop]
        }
    }

    return target
}

// deep copy, but not overwriting dest leaves
function clone(source, deep) {
    let destination = {}
    for (var property in source) {
        if (typeof source[property] === "object" && deep) { 
            destination[property] = {}
            clone(source[property], destination[property]);
        } else {
            destination[property] = source[property];
        }
       }
    return destination
}


function convert(value, unit, units, targetUnit) {
    if (unit!=targetUnit)
    {
        let factor = getConversionFactor(unit, units, targetUnit)
        value = value * factor 
        value = Math.round(value*100)/100
    }
    return value;
}

function getConversionFactor(unit, units, targetUnit) {
    if (units[unit][targetUnit])
        return units[unit][targetUnit]
    else
        throw new Error("no conversion for : "+unit+" to "+targetUnit)
}
function mergeNumber(newFlow, flow, prop, units, unit, aggregate) {
    let newValue = 0.0
    let wasSet=false
    if (flow&&flow[prop]) {
        if (aggregate)
            newValue = convert(flow[prop], flow.unit, units, unit)
        else
            newValue += convert(flow[prop], flow.unit, units, unit)
        wasSet= true
    }
    if (newFlow&&newFlow[prop]) {
        if (aggregate)
            newValue = convert(newFlow[prop], newFlow.unit, units, unit)
        else
            newValue += convert(newFlow[prop], newFlow.unit, units, unit)
        wasSet= true
    }

    return wasSet?newValue:undefined;
}

Set.prototype.toJSON = function toJSON() {
  return [...Set.prototype.values.call(this)];
}

const contractProto = {
    start:null, duration:null,end:null, amount:null, acct:null, rythm:null, flows : [], unit: null
}
const prototypeAccount = {
    unit:null, balances: []
}

const accounts = {
    post : {
        unit:"chf" 
        ,zahlungs : { 
            balances :{'20170104' : 1000, '20171231' : 600, },
         },
        spar : { 
            start: 20170101, rythm: "M", amount: 1000
        }
        ,usd : { unit:"usd", balances :{'20170101' : 100 }}
        ,eur : { unit:"eur",  balances :{'20170101' : 10 }}
        ,spar : { }
        ,"3a" : { }
    }
    ,tnb : {
        unit:"usd" 
        ,checking: {balances :{'20170101' : 2000 }}
        ,savings: {}
    }
}

const units = {
    chf: {eur:1/1.1, usd:1.0}
    ,eur: {chf:1.1, usd:1.1}
    ,usd: {eur:1/1.1, chf:1.0}
}

// Key  Shorthand
// years    y
// quarters Q
// months   M
// weeks    w
// days d
// hours    h
// minutes  m
// seconds  s
// milliseconds ms
let testContract = {
    acct: "zahlungs",
    unit: "chf",
    rythm: "M",
    start: "20170104", 
    amount:184,
    parking: {
        amount:150,
    },
    oil: {
        rythm: "y",
        start: "20171101", 
        amount:200,
    },
    fluid: {
        rythm: "Q",
        start: "20170114", 
        amount:20,
    },
    test: {
        rythm: "w",
        start: "20170114", 
        amount:5,
    },
    income: {
        start: "201701end", 
        amount:-350,
        unit:"eur"
    },
    income2: {
        acct: "checking",
        start: "201701end", 
        amount:-300,
        unit:"usd"
    },
}

let start =  moment('20170101' , 'YYYYMMDD' )
let end = moment('20171231' , 'YYYYMMDD' )
let windowSize= "w"

let days=genDays(start,end)
let normalisedContracts = normaliseContracts(testContract, days, contractProto)

var normalizedAcccounts = inherit(accounts,{}, prototypeAccount, true);
let targetAccounts = ["zahlungs"]
//let targetAccounts = ["zahlungs", "checking", "spar"]
//let accountExtract = extractAccount(account, normalizedAcccounts);

var mergedFlows = getMergedFlowsAllAccounts(days,normalisedContracts, normalizedAcccounts, targetAccounts, units, contractProto, "chf")

console.log(JSON.stringify(mergedFlows, null, 2))

var windowedFlows = mergeToWindow(mergedFlows , "w")

console.log(JSON.stringify(windowedFlows, null, 2))




</script>

</head>

<body>

   <div>  hello world hi xxddxx</div>

</body>

</html>