<!DOCTYPE html>
<html>

<head>
    <meta charset="UTF-8">
    <title>Flows2</title>
    <!--     <script type="text/javascript" src="lazy.js"></script>
 -->
    <!-- optional: if you want support for DOM event and AJAX-based sequences: -->
    <!--     <script type="text/javascript" src="lazy.browser.js"></script>
 -->
    <script type="text/javascript" src="moment-with-locales.js"></script>
    <script type="text/javascript" src="lodash.js"></script>
<!--     <script type="text/javascript" src="flows2.js"></script>
 -->    <script type="text/javascript" src="jquery-3.2.1.js"></script>
    <script type="text/javascript">
    // [accountNames],[all-flows]=> genAllAccountLines => [chunkFlows], Total-chunkedFlows
    function genAllAccountLines(normalizedAcccounts, allFlows,start, end,unit, rythm) {
        // walk-contracts
        let accountNames = []
        walkPojo(normalizedAcccounts, (account, name) => {
            if (!isAcccount(account)) return 
                accountNames.push(name)
        })

        let result = { totalFlows: {}, allChunkedFlows: [] }
        accountNames.forEach(accountName => {
            let balances = findPropOnObject("balances", findPropOnObject(accountName, normalizedAcccounts))
            result.allChunkedFlows.push(genAccountLine(allFlows, start, end,balances, unit, rythm, accountName))
        })
        return result
    }
    function isAcccount(account) {
        return account && account.balances !== undefined  
    }
    function isContract(contract) {
        return contract && contract.amount !== undefined  && contract.rythm !== undefined  
    }
    // contracts,start,end => genAllContractLines => [all-chunkFlows],[all-flows]
    function genAllContractLines(normalizedContracts, start, end, rythm) {
        // walk-contracts
        let allResults = { allFlows: [], allChunkedFlows: [] }
        walkPojo(normalizedContracts, contract => {
            if (!isContract(contract)) return 
            let result = genContractLine(contract, start, end, rythm)
            allResults.allFlows.push(result.flows)
            allResults.allChunkedFlows.push(result.chunkedFlows)
        })
        return allResults
    }

    // [all-flows],accountName,unit=>genAccountLine=>flows{windows:{ amount, unit, accounts, balance },...}
    function genAccountLine( allFlows, start, end,balances, unit, rythm, accountName) {

        let rolledUpFlows = rollupFlows(start, end, allFlows, [accountName], unit)
        let actualFlows = actualizeFlows(rolledUpFlows, balances)
        let chunkedFlows = chunkFlows(start, end, actualFlows, rythm)
        return chunkedFlows
    }

    function rollupFlows(start, end, allFlows, accountNames, unit) {
//        let start = _.chain(flows).keys().head().value()
//        let end = _.findLastKey(flows)
        let rolledUpFlows = genFlows(start, end, "d")

        allFlows.forEach(flows => {
            // filter out none listed accounts
            let flow = _.chain(flows).values().head().value()
            if (accountNames && accountNames.length && accountNames[0] !== undefined && !(flow && flow.account && accountNames.indexOf(flow.account) != -1))
                return
    
            _.reduce(rolledUpFlows, (dummy, rollup, day) => {
                rolledUpFlows[day] = mergeFlow(rollup, flows[day], unit)
            })
        })
        return rolledUpFlows
    }

    // contract,start,end,unit,rythm=>genContractLine=>chunkFlows
    function genContractLine(normalizedContract, start, end, rythm) {
        let result = {}
        result.flows = genFlows(start, end, null, normalizedContract)
        result.chunkedFlows = chunkFlows(start, end, result.flows, rythm)
        return result
    }

    // contract,start,end,unit=>genFlows=>flows{day:{ amount, unit, account },...}

    function genFlows(start, end, rythm, normalizedContract) {
        let flows = {}
        if (normalizedContract && normalizedContract.start > start)
            start = normalizedContract.start
        if (normalizedContract && normalizedContract.end < end)
            end = normalizedContract.end
        if (normalizedContract && !rythm)
            rythm = normalizedContract.rythm

        let current = start
        let next;

        while (current <= end) {
            let flow = {}
            if (normalizedContract) {
                flow.amount = normalizedContract.amount
                flow.unit = normalizedContract.unit
                flow.account = normalizedContract.account
            }
            flows[current] = flow;

            next = moment(current, 'YYYYMMDD').add(1, rythm).format('YYYYMMDD')
            if (next == current) { // in case moment duration/rythm code is incorrect:moment returns same date
                throw "constant current date :" + current + " rythm: " + rythm
            }
            current = next;
        }
        return flows
    }


    // flows/actualFlows,rythm=>chunkFlows=>chunkedFlows{windows:{ amount, unit, accounts },...}
    // create window and gather flows and merge them
    function chunkFlows(start, last, flows, rythm) {
        //let start = _.chain(flows).keys().head().value()
        //let last = _.findLastKey(flows)
        let chunkedFlows = {}

        let current = start
        let next;

        // current and next: last-next-1-rythm

        while (current <= last) {
            next = moment(current, 'YYYYMMDD').add(1, rythm).format('YYYYMMDD')
            let nextminusone = moment(next, 'YYYYMMDD').add(-1, "d").format('YYYYMMDD')
            let chunkName = current + "-" + nextminusone + "-" + rythm

            chunkedFlows[chunkName] = gatherAndMergeFlows(current, nextminusone, flows)

            if (next == current) {
                throw "constant current date :" + current + " , rythm: " + rythm
            }
            current = next
        }
        return chunkedFlows
    }

    function gatherAndMergeFlows(start, last, flows) {
        let chunk = { flow: 0 }
        let current = start
        while (current <= last) {
            chunk = mergeFlow(chunk, flows[current])
            next = moment(current, 'YYYYMMDD').add(1, "d").format('YYYYMMDD')
            current = next
        }
        return chunk
    }
    // mergeFlow - flow,unit,account:lazy init unit,account,add flow
    function mergeFlow(oldFlow, flow, unit) {
        let merged = {}
        merged.unit = unit || oldFlow.unit || flow && flow.unit
        merged.account = oldFlow.account || flow && flow.account
        merged.amount = oldFlow.amount || 0

        merged.balance = (flow && flow.balance) || oldFlow.balance
        merged.oldBalance = (flow && flow.oldBalance) || oldFlow.oldBalance

        if (flow && flow.amount) {
            merged.amount += convert(flow.amount, flow.unit, merged.unit)
            merged.amount = Math.round(merged.amount * 100) / 100
        }

        return merged
    }

    function convert(value, unit, targetUnit) {
        if (unit && unit != targetUnit) {
            let factor = getConversionFactor(unit, targetUnit)
            value = value * factor
        }
        return value;
    }

    function getConversionFactor(unit, targetUnit) {
        if (units[unit][targetUnit])
            return units[unit][targetUnit]
        else
            throw new Error("no conversion for : "+unit+" to "+targetUnit)
    }
    // flows,account:{balances,unit,...}=>actualizeFlows=>actualFlows{day:{ amount, unit, account, balance, oldBalance,.. },...}
    function actualizeFlows(flows, balances) {
        let balance = 0
        _.reduce(flows, (flows, flow, day) => {
            if (flow.amount !== undefined)
                balance += flow.amount
            flow.balance = balance
            if (balances[day]!==undefined) {
                flow.oldBalance = flow.balance
                flow.balance = balances[day]
            }
            return flows
        }, flows)

        return flows
    }

    function findPropOnObject(prop, source) {
        for (var property in source) {
            let found = undefined
            if (prop == property) {
                found = source[property];
            } else if (typeof source[property] === "object") {
                found = findPropOnObject(prop, source[property]);
            }
            if (found)
                return found
        }
        return undefined
    }

    function normalizeAmount(contract) {
        // set start
        // norm start
        if (!contract.amount)
            return
        contract.amount = -contract.amount
    }

    function normalizeDates(contract) {
        // set start
        // norm start
        if (!contract.start)
            return
        normalizeDate(contract, "start")
        normalizeDate(contract, "end")
    }

    function normalizeDate(contract, prop) {
        // set start
        // norm start
        let date = contract[prop];
        if (date) {
            let endMarker = "end"
            if (date.indexOf(endMarker) == date.length - endMarker.length) {
                if (date.length != 6 + endMarker.length)
                    throw "date not YYYYMM formate: " + JSON.stringify(contract, null, 2)
                let begin = moment(date.substring(0, 6), 'YYYYMM')
                let end = begin.endOf('month');
                contract[prop] = end.format('YYYYMMDD')
            }
        }
    }

    function normaliseContracts(contracts, contractProto) {
        contracts = inherit(contracts, {}, contractProto, true)
        walkPojo(contracts, normalizeDates)
        walkPojo(contracts, normalizeAmount)
        return contracts
    }

    function normaliseAccounts(accounts, start, end, prototypeAccount) {
        let normalizedAcccounts = inherit(accounts, {}, prototypeAccount, true);
        // bring last balance before start day forward, if start day does not have balance ??
        // go down balances until >= start day, if start day not defined and there is one before copy it in on start day

        function bringFowardOldBalance() {

        }
        walkPojo(normalizedAcccounts, bringFowardOldBalance)
        return normalizedAcccounts
    }
    // deep copy of undefined attributes
    function inherit(source, parent, prototype, deep) {
        // filter parent 
        let target = {}

        // copy source props
        //   if prop in prototype: deep copy/clone 
        for (var prop in source) {
            if (prototype[prop] !== undefined) {
                if (typeof source[prop] == "object") {
                    target[prop] = clone(source[prop], true)
                } else {
                    target[prop] = source[prop]
                }
            }
        }

        // inheit from parent
        for (var prop in parent) {
            if (prototype[prop] === null && target[prop] === undefined && parent[prop] !== undefined) {
                target[prop] = parent[prop]
                if (prototype.inherited) {
                    target.inherited = target.inherited || []
                    target.inherited.push(prop)
                }
            }
        }

        for (var prop in source) {
            if (prototype[prop] === undefined && typeof source[prop] == "object") {
                if (deep)
                    target[prop] = inherit(source[prop], target, prototype, deep)
                else
                    target[prop] = source[prop]
            }
        }

        return target
    }

    // deep copy, but not overwriting dest leaves
    function clone(source, deep) {
        let destination = {}
        for (var property in source) {
            if (typeof source[property] === "object" && deep) {
                destination[property] = {}
                clone(source[property], destination[property]);
            } else {
                destination[property] = source[property];
            }
        }
        return destination
    }

    function walkPojo(source, iterator, key, level, path)
    {
        if (level===undefined)
            level = 0
        if (path===undefined)
            path = ""
        iterator(source, key, level, path)
        if (key===undefined)
            key = ""
        for (var property in source) {
            if (typeof source[property] === "object") { 
                walkPojo(source[property], iterator, property, level+1, path+"."+key)   
            }
        } 

    }

    Set.prototype.toJSON = function toJSON() {
        return [...Set.prototype.values.call(this)];
    }

    const contractProto = {
        start: null,
        duration: null,
        end: null,
        amount: null,
        account: null,
        rythm: null,
        flows: [],
        unit: null,
        inherited: []
    }
    const prototypeAccount = {
        unit: null,
        balances: [],
        inherited: []
    }

    const accounts = {
        post: {
            unit: "chf",
            zahlungs: {
                balances: { '20170104': 1000, '20171231': 600, },
            },
            spar: {
                start: 20170101,
                rythm: "M",
                amount: 1000
            },
            usd: { unit: "usd", balances: { '20170101': 100 } },
            eur: { unit: "eur", balances: { '20170101': 10 } },
            spar: {},
            "3a": {}
        },
        tnb: {
            unit: "usd",
            checking: {
                balances: { '20170101': 2000 }
            },
            savings: {}
        }
    }

    const units = {
        chf: { eur: 1 / 1.2, usd: 1.1 },
        eur: { chf: 1.2, usd: 1.1 },
        usd: { eur: 1 / 1.1, chf: 1 / 1.1 }
    }

    // Key  Shorthand
    // years    y
    // quarters Q
    // months   M
    // weeks    w
    // days d
    // hours    h
    // minutes  m
    // seconds  s
    // milliseconds ms
    let testContract = {
        account: "zahlungs",
        unit: "chf",
        rythm: "M",
        start: "20170104",
        amount: 184,
        parking: {
            amount: 150,
        },
        oil: {
            rythm: "y",
            start: "20171101",
            amount: 200,
        },
        fluid: {
            rythm: "Q",
            start: "20170114",
            amount: 20,
        },
        test: {
            rythm: "w",
            start: "20170114",
            amount: 5,
            testsub: {
                rythm: "w",
                start: "20170114",
                amount: 5,
            },
        },
        income: {
            start: "201701end",
            amount: -350,
            unit: "eur"
        },
        income2: {
            account: "checking",
            start: "201701end",
            amount: -300,
            unit: "usd"
        },
    }

    let start = '20170101'
    let end = '20171231'
        let windowSize = "M"

    //let targetAccounts = ["zahlungs", "checking", "spar"]
    let targetCurrency = "chf"

    let normalizedAcccounts = normaliseAccounts(accounts, start, end, prototypeAccount)

    let normalisedContracts = normaliseContracts(testContract, contractProto)

    let flows = genAllContractLines(normalisedContracts, start, end, windowSize)

    let acctflows = genAccountLine(flows.allFlows, start, end, normalizedAcccounts.post.zahlungs.balances, "chf", windowSize, "zahlungs")

    let allAcctflows = genAllAccountLines(normalizedAcccounts, flows.allFlows,start, end,"chf", windowSize) 

    console.log(JSON.stringify(allAcctflows, null, 2))

    // gen all contracts: if dates or rythm change
    // gen all accounts: if above or unit change
    </script>
</head>

<body>
    <div id="flows"> </div>
</body>

</html>