<!DOCTYPE html>
<html>



<head>
    <meta charset="UTF-8">
    <title>Flows2</title>
    <!--     <script type="text/javascript" src="lazy.js"></script>
 -->
    <!-- optional: if you want support for DOM event and AJAX-based sequences: -->
    <!--     <script type="text/javascript" src="lazy.browser.js"></script>
 -->
    <script type="text/javascript" src="moment-with-locales.js"></script>
    <script type="text/javascript" src="lodash.js"></script>
    <!--     <script type="text/javascript" src="flows2.js"></script>
 -->
    <script type="text/javascript" src="jquery-3.2.1.js"></script>
    <script type="text/javascript">

    // todo: 
    //  non-contract objects/aggregates are not displayed: aggregate must be displayed, calculated: how to handle missing detail?
    //  normalizing balances: find previous balance from start date back, if exists, gen flows && balances until start date, insert this calculated balance into account balances list
    // bug: yearly first of jan does not rollup
    // track negative balances in red, pop up with dates/details 
    // zoom in gestures: pop up with/jump to stack for one level of detail or 2 more: M -> w or -> day explode 
    // level show field: 1 to show major line items
    // screen splitting a la excel 
    // gui jquery code redesign - collapse event handling!!

    // [accountNames],[all-flows]=> genAllAccountLines => [chunkFlows], Total-chunkedFlows
    function genAllAccountLines(accountNames, normalizedAcccounts, allFlows, start, end, unit, rythm) {
        // walk-contracts
        let result = { totalFlows: {}, allChunkedFlows: [], paths: [], accounts:[] }
        accountNames.forEach(accountName => {
            let balances = findPropOnObject("balances", findPropOnObject(accountName, normalizedAcccounts))
            result.allChunkedFlows.push(genAccountLine(allFlows, start, end, balances, unit, rythm, accountName))
            result.paths.push(accountName)
            result.accounts.push(findPropOnObject(accountName, normalizedAcccounts))

        })
        return result
    }

    function getAllAccountNames(normalizedAcccounts) {
        let accountNames = []
        walkPojo(normalizedAcccounts, (account, name) => {
            if (!isAcccount(account)) return
            accountNames.push(name)
        })
        return accountNames
    }

    function isAcccount(account) {
        return account && account.balances !== undefined
    }

    function isContract(contract) {
        return contract && contract.amount !== undefined && contract.start !== undefined
    }
    // contracts,start,end => genAllContractLines => [all-chunkFlows],[all-flows]
    function genAllContractLines(normalizedContracts, start, end, rythm) {
        // walk-contracts
        let allResults = { allFlows: [], allChunkedFlows: [], allChunkedRowupFlows: [], paths: [], contracts: [], aggregateCounts:[], immediateChildren: [] }
        walkPojo(normalizedContracts, (contract, key, level, path, immediateChildren) => {
            if (!isContract(contract) && ! immediateChildren) return
            let results = { allFlows: [], allChunkedFlows: [], allChunkedRowupFlows: [], paths: [], contracts: [], aggregateCounts:[] }
            let result = genContractLine(contract, start, end, rythm, immediateChildren)

            allResults.allFlows.unshift(result.flows)
            allResults.allChunkedFlows.unshift(result.chunkedFlows)
            allResults.allChunkedRowupFlows.unshift(result.chunkedRollupFlows)
            // rollup for each account, if there is subs 
            result.contract = contract; 
            allResults.contracts.unshift(contract)
            result.path = path + (key ? key : ""); 
            allResults.paths.unshift(result.path)
            allResults.aggregateCounts.unshift(result.aggregateCount)
            allResults.immediateChildren.unshift(immediateChildren)
            return result;
        })
        return allResults
    }

    // [all-flows],accountName,unit=>genAccountLine=>flows{windows:{ amount, unit, accounts, balance },...}
    function genAccountLine(allFlows, start, end, balances, unit, rythm, accountName) {

        let rolledUpFlows = genRollupFlows(start, end, allFlows, [accountName], unit)
        let actualFlows = actualizeFlows(rolledUpFlows, balances)
        let chunkedFlows = chunkFlows(start, end, actualFlows, rythm)
        return chunkedFlows
    }

    function genRollupFlows(start, end, allFlows, accountNames, unit) {
        //        let start = _.chain(flows).keys().head().value()
        //        let end = _.findLastKey(flows)
        let rolledUpFlows = genFlows(start, end, "d")

        if (allFlows) {
            allFlows.forEach(flows => {
                // filter out none listed accounts
                let flow = _.chain(flows).values().head().value()
                if (accountNames && accountNames.length && accountNames[0] !== undefined && !(flow && flow.account && accountNames.indexOf(flow.account) != -1))
                    return

                _.reduce(rolledUpFlows, (dummy, rollup, day) => {
                    rolledUpFlows[day] = mergeFlow(rollup, flows[day], unit)
                })
            })
        }
        return rolledUpFlows
    }

    // contract,start,end,unit,rythm=>genContractLine=>chunkFlows
    function genContractLine(normalizedContract, start, end, rythm, immediateChildren) {
        let result = {}
        result.flows = genFlows(start, end, null, normalizedContract)
        result.chunkedFlows = chunkFlows(start, end, result.flows, rythm)

        // fetch all from this contract down: flag when there are not sub contracts:?some null value 
        //let allFlows = getAllFlows(normalizedContract, start, end)
        let childRollupFlows = immediateChildren && immediateChildren.rollupFlows 

        let rollupFlows = genRollupFlows(start, end, (childRollupFlows|| []).concat(( result.flows|| [])), null, normalizedContract.unit)
        result.chunkedRollupFlows = chunkFlows(start, end, rollupFlows, rythm)
        let aggregateCount= immediateChildren && immediateChildren.rollupFlows&& immediateChildren.rollupFlows.length || 0
        result.aggregateCount = aggregateCount
        return result
    }

    // contract,start,end,unit,rythm=>genContractLine=>chunkFlows
    function genContractLineAndSubs(normalizedContract, start, end) {
        let flows = genFlows(start, end, null, normalizedContract)
        return flows
    }

    function getAllFlows(normalizedContracts, start, end) {
        // walk-contracts
        let allFlows = []
        walkPojo(normalizedContracts, (contract, key, level, path) => {
            if (!isContract(contract)) return
            let flows = genContractLineAndSubs(contract, start, end)
            allFlows.push(flows)
        })
        return allFlows
    }

    function  parseRythm(rythm) {
        let res = { length:1, rythm:""}
        let a = rythm.split("-")
        if (a.length==1)
            res.rythm=a[0]
        else {
            res.rythm=a[1]
            res.length=parseInt(a[0])            
        }
        if (res.rythm=="y")
            console.log("found")
        return res
    }

    // contract,start,end,unit=>genFlows=>flows{day:{ amount, unit, account },...}
    function genFlows(start, end, rythm, normalizedContract) {
        let flows = {}
        if (normalizedContract && normalizedContract.start > start)
            start = normalizedContract.start
        if (normalizedContract && normalizedContract.end < end)
            end = normalizedContract.end
        if (normalizedContract && !rythm)
            rythm = normalizedContract && normalizedContract.rythm

        if (rythm) {
            let current = start
            let next;
            let parsedRythm = parseRythm(rythm)

            while (current <= end) {
                let flow = {}

                flow.amount = normalizedContract && normalizedContract.amount
                flow.unit = normalizedContract && normalizedContract.unit
                flow.account = normalizedContract && normalizedContract.account
                flows[current] = flow;
               
                for (i = 0; i < parsedRythm.length; i++) { 
                    next = moment(current, 'YYYYMMDD').add(1, parsedRythm.rythm).format('YYYYMMDD')
                    if (next == current) { // in case moment duration/rythm code is incorrect:moment returns same date
                        throw "constant current date :" + current + " rythm: " + rythm
                    }
                    current = next;
                }
            }
        }
        return flows
    }


    // flows/actualFlows,rythm=>chunkFlows=>chunkedFlows{windows:{ amount, unit, accounts },...}
    // create window and gather flows and merge them
    function chunkFlows(start, last, flows, rythm) {
        //let start = _.chain(flows).keys().head().value()
        //let last = _.findLastKey(flows)
        let chunkedFlows = {}

        let current = start
        let next;

        // current and next: last-next-1-rythm

        while (current <= last) {
            next = moment(current, 'YYYYMMDD').add(1, rythm).format('YYYYMMDD')
            if (next == current) {
                throw "constant current date :" + current + " , rythm: " + rythm
            }
            let nextminusone = moment(next, 'YYYYMMDD').add(-1, "d").format('YYYYMMDD')
            let chunkName = current + "-" + nextminusone + "-" + rythm

            chunkedFlows[chunkName] = gatherAndMergeFlows(current, nextminusone, flows)

            current = next
        }
        return chunkedFlows
    }

    function gatherAndMergeFlows(start, last, flows) {
        let chunk = { flow: 0 }
        if (!flows) return chunk;

        let current = start
        while (current <= last) {
            chunk = mergeFlow(chunk, flows[current])
            next = moment(current, 'YYYYMMDD').add(1, "d").format('YYYYMMDD')
            current = next
        }
        return chunk
    }
    // mergeFlow - flow,unit,account:lazy init unit,account,add flow
    function mergeFlow(oldFlow, flow, unit) {
        let merged = {}
        merged.unit = unit || oldFlow.unit || flow && flow.unit
        // if diff to array
        if ((oldFlow && oldFlow.account && Array.isArray(oldFlow.account)) || (flow && flow.account && Array.isArray(flow.account)) || (flow && oldFlow && oldFlow.account && flow.account && oldFlow.account != flow.account)) {
            merged.account = []
            if (oldFlow && oldFlow.account && Array.isArray(oldFlow.account))
                merged.account = [...new Set([...merged.account, ...oldFlow.account])];
            else if (oldFlow.account)
                merged.account.push(oldFlow.account)

            if (flow && flow.account && Array.isArray(flow.account))
                merged.account = [...new Set([...merged.account, ...flow.account])];
            else if (flow&&flow.account)
                merged.account.push(flow.account)

        } else {
            merged.account = oldFlow.account || flow && flow.account
        }
        merged.amount = oldFlow.amount || 0

        merged.balance = (flow && flow.balance) || oldFlow.balance
        merged.balance = Math.round(merged.balance * 100) / 100
        merged.oldBalance = (flow && flow.oldBalance) || oldFlow.oldBalance

        if (flow && flow.amount) {
            merged.amount += convert(flow.amount, flow.unit, merged.unit)
            merged.amount = Math.round(merged.amount * 100) / 100
        }

        return merged
    }

    function convert(value, unit, targetUnit) {
        if (unit && unit != targetUnit) {
            let factor = getConversionFactor(unit, targetUnit)
            value = value * factor
        }
        return value;
    }

    function getConversionFactor(unit, targetUnit) {
        if (units[unit][targetUnit])
            return units[unit][targetUnit]
        else
            throw new Error("no conversion for : " + unit + " to " + targetUnit)
    }
    // flows,account:{balances,unit,...}=>actualizeFlows=>actualFlows{day:{ amount, unit, account, balance, oldBalance,.. },...}
    function actualizeFlows(flows, balances) {
        let balance = 0
        _.reduce(flows, (flows, flow, day) => {
            if (flow.amount !== undefined)
                balance += flow.amount
            flow.balance = balance
            if (balances[day] !== undefined) {
                flow.oldBalance = flow.balance
                flow.balance = balances[day]
            }
            return flows
        }, flows)

        return flows
    }

    function findPropOnObject(prop, source) {
        for (var property in source) {
            let found = undefined
            if (prop == property) {
                found = source[property];
            } else if (typeof source[property] === "object") {
                found = findPropOnObject(prop, source[property]);
            }
            if (found)
                return found
        }
        return undefined
    }

    function normalizeAmount(contract) {
        // set start
        // norm start
        if (!contract.amount)
            return
        contract.amount = -contract.amount
    }

    function normalizeTransfers(contracts) {

        return function (contract, key, level, path) {
            if (!contract.contract)
                return
            let transferContract = 
                _(path.split("."))
                .filter(elem=>elem)
                .unshift(contract.contract)
                .push(key)
                .reduce((current,pathElement)=>{
                    current[pathElement] = current[pathElement]||{}; 
                    return current[pathElement] 
                }, contracts)
            clone(contract, true, transferContract)
            transferContract.amount = -transferContract.amount
            transferContract.contract = undefined
            transferContract.account =  transferContract.transferAccount ||  transferContract.account
            transferContract.transferAccount = undefined
        }
    }

    function normalizeDates(contract) {
        // set start
        // norm start
        if (!contract.start)
            return
        normalizeDate(contract, "start")
        normalizeDate(contract, "end")
    }

    function normalizeDate(contract, prop) {
        // set start
        // norm start
        let date = contract[prop];
        if (date) {
            let endMarker = "end"
            if (date.indexOf(endMarker) == date.length - endMarker.length) {
                if (date.length != 6 + endMarker.length)
                    throw "date not YYYYMM formate: " + JSON.stringify(contract, null, 2)
                let begin = moment(date.substring(0, 6), 'YYYYMM')
                let end = begin.endOf('month');
                contract[prop] = end.format('YYYYMMDD')
            }
        }
    }

    function normaliseContracts(contracts, contractProto) {
        contracts = inherit(contracts, {}, contractProto, true)
        walkPojo(contracts, normalizeDates)
        walkPojo(contracts, normalizeAmount)
        walkPojo(contracts, normalizeTransfers(contracts))
        return contracts
    }

    function normaliseAccounts(accounts, start, end, prototypeAccount) {
        let normalizedAcccounts = inherit(accounts, {}, prototypeAccount, true);
        // bring last balance before start day forward, if start day does not have balance ??
        // go down balances until >= start day, if start day not defined and there is one before copy it in on start day

        function bringFowardOldBalance() {

        }
        walkPojo(normalizedAcccounts, bringFowardOldBalance)
        return normalizedAcccounts
    }
    // deep copy of undefined attributes
    function inherit(source, parent, prototype, deep) {
        // filter parent 
        let target = {}

        // copy source props
        //   if prop in prototype: deep copy/clone 
        for (var prop in source) {
            if (prototype[prop] !== undefined) {
                if (typeof source[prop] == "object") {
                    target[prop] = clone(source[prop], true)
                } else {
                    target[prop] = source[prop]
                }
            }
        }

        // inheit from parent
        for (var prop in parent) {
            if (prototype[prop] === null && target[prop] === undefined && parent[prop] !== undefined) {
                target[prop] = parent[prop]
                if (prototype.inherited) {
                    target.inherited = target.inherited || []
                    target.inherited.push(prop)
                }
            }
        }

        for (var prop in source) {
            if (prototype[prop] === undefined && typeof source[prop] == "object") {
                if (deep)
                    target[prop] = inherit(source[prop], target, prototype, deep)
                else
                    target[prop] = source[prop]
            }
        }

        return target
    }

    // deep copy, but not overwriting dest leaves
    function clone(source, deep, destination) {
        if (!destination)
            destination = {}
        for (var property in source) {
            if (typeof source[property] === "object" && deep) {
                if (Array.isArray(source[property]))
                    destination[property] = []
                else
                    destination[property] = {}
                clone(source[property], deep, destination[property]);
            } else {
                destination[property] = source[property];
            }
        }
        return destination
    }

    function walkPojo(source, iterator, key, level, path) {

        if (level === undefined)
            level = 0
        if (path === undefined)
            path = "."
        let subPath = path
        if (key)
            subPath += key + "."
        let res;
        for (var property in source) {
            if (typeof source[property] === "object") {
                let subres = walkPojo(source[property], iterator, property, level + 1, subPath)
                if (subres!==undefined ) 
                    res = (res || []).concat(Array.isArray(subres)? subres: [subres])
            }
        }
        res = iterator(source, key, level, path, res)
        if (res !== undefined && !Array.isArray(res))
            res = [res]
        return res
    }

    Set.prototype.toJSON = function toJSON() {
        return [...Set.prototype.values.call(this)];
    }

    const contractProto = {
        start: null,
        duration: null,
        end: null,
        amount: null,
        account: null,
        rythm: null,
        flows: [],
        unit: null,
        inherited: [],
        contract:"",
        transferAccount:""
    }
    const prototypeAccount = {
        unit: null,
        balances: [],
        inherited: []
    }
    </script>
    <script type="text/javascript">
    var allflowsg;
    const accounts = {
        post: {
            unit: "chf",
            zahlungs: {
                balances: {
                    '20170104': 1000,
                    '20171231': 600,
                    '20171031': 800,
                },
                // transfer??
                //spar: { start: 20170101, rythm: "M",  amount: 1000 },
            },

            usd: {
                unit: "usd",
                balances: {
                    '20170101': 100,
                }
            },
            eur: {
                unit: "eur",
                balances: {
                    '20170101': 10,
                }
            },
            spar: {
                balances: {
                    '20170101': 100,
                }
            },
            "3a": {
                balances: {
                    '20170101': 100,
                }
            }
        },
        tnb: {
            unit: "usd",
            checking: {
                balances: {
                    '20170101': 2000,
                }
            },
            savings: {
                balances: {
                    '20170101': 2000,
                }
            }
        }
    }

    const units = {
        chf: { eur: 1 / 1.2, usd: 1.1 },
        eur: { chf: 1.2, usd: 1.1 },
        usd: { eur: 1 / 1.1, chf: 1 / 1.1 }
    }

    // Key  Shorthand
    // years    y
    // quarters Q
    // months   M
    // weeks    w
    // days d
    // hours    h
    // minutes  m
    // seconds  s
    // milliseconds ms
    let contracts = {
        account: "zahlungs",
        unit: "chf",
        rythm: "M",
        start: "20160101",

        ruckbildungen : {
            account:"spar",
        },
        apartment : {
            miete : {
                amount: 1800,
            },
            utils : {
                amount: 150,
            },
            elect : {
                amount: 150,
                rythm:"Q"
            },
            insurance : {
                rythm:"y",
                haftpflicht : {
                    amount: 150,
                },
                hausrat : {
                    amount: 250,
                },
            },
        },
        health : {
        },
        income : {
            lohn: {
                amount:-10000,
                rythm:"M",
                start:"20170131",
                bonus: {
                    amount:-10000,
                    rythm:"y",
                    start:"20171231",
                }
            }
        },
        entertainmenttravel : {
            michigan :  {
                amount: 1000,
                start:"20170701",
                rythm: "y",
            },
        },
        food : {
        },
        olivia : {
        },
        auto : {
            gas : {
                amount: 100,
            },
            insurance : {
                kaskoetc : {
                    amount: 100,
                },
                garanteeextension : {
                    amount: 100,
                },
            },
            oil : {
                amount: 100,
            },
            service : {
                amount: 100,
            },
            amortisation : {
                contract: "ruckbildungen",
                amount: 250,
                transferAccount:"spar"
            },
            tires : {
                rotation : {
                    amount: 100,
                },
                replacement : {
                    amount: 100,
                },
            },
            replacement : {
                start: "20221231",
                rythm:"5-y",
                account: "spar",
                sell : {
                    amount: -15000,
                },
                buy : {
                    amount: 30000,
                },
            },
        }
    }

    let testContract = {
        account: "zahlungs",
        unit: "chf",
        rythm: "M",
        start: "20170104",
        amount: 184,
        parking: {
            amount: 150,
        },
        oil: {
            rythm: "y",
            start: "20171101",
            amount: 200,
        },
        fluid: {
            rythm: "Q",
            start: "20170114",
            amount: 20,
        },
        test: {
            rythm: "w",
            start: "20170114",
            amount: 5,
            testsub: {
                rythm: "w",
                start: "20170114",
                amount: 5,
            },
        },
        income: {
            start: "201701end",
            amount: -350,
            unit: "eur"
        },
        income2: {
            account: "checking",
            start: "201701end",
            amount: -300,
            unit: "usd"
        },
    }

    let start = '20170101'
    let end = '20171231'
    let windowSize = "M"

    //let targetAccounts = ["zahlungs", "checking", "spar"]
    let targetCurrency = "chf"

    let normalizedAcccounts = normaliseAccounts(accounts, start, end, prototypeAccount)

    let normalisedContracts = normaliseContracts(contracts, contractProto)


    // console.log(JSON.stringify(allAcctflows, null, 2))

    // gen all contracts: if dates or rythm change
    // gen all accounts: if above or unit change
    // refresh/redraw, generate, loop contracts, expand logic, css, 
    // budget examples, mine, a house?, retirement 
           function expandmax() {
                let $tr = $(this)

                $('tr').each((index, tr) => {
                    let $tr = $(tr)
                    let myPath = $tr.data("path")
                    let myLevel = $tr.data("level")
                    let myIsDetail = $tr.hasClass("detail")
                    let myAggregateCount = $tr.data("aggregateCount")
                    let myHasChildren = $tr.data("hasChildren")
                    let contract = $tr.data("contract")

                    if ( myIsDetail && isContract(contract))
                        $tr.show() 
                    else if ( !myIsDetail && myHasChildren && !isContract(contract))
                        $tr.show() 
                    else
                        $tr.hide() 

                })

                // $tr
                //     .off("click", toggleHide)
                //     .on("click", toggleShow)

            }

    function refreshWindows() {

        let allFlows = genAllContractLines(normalisedContracts, start, end, windowSize)
        allflowsg = allFlows
        let allAccountNames = getAllAccountNames(normalizedAcccounts)
        let allAcctflows = genAllAccountLines(allAccountNames, normalizedAcccounts, allFlows.allFlows, start, end, targetCurrency, windowSize)

        let $tableEnd = createTable( chunkFlows(start, end, null, windowSize));

        {
            allFlows.allFlows.forEach((flows, index)=>{
                let level = (allFlows.paths[index].match(/\./g) || []).length;
                if (allFlows.paths[index].length==1)
                    level=0;
                
                appendRow($tableEnd, allFlows.contracts[index],  allFlows.allChunkedRowupFlows[index],  allFlows.paths[index].split(".").pop(), level, allFlows.paths[index], "rollup", true, allFlows.aggregateCounts[index], allFlows.immediateChildren && allFlows.immediateChildren.length)

                appendRow($tableEnd, allFlows.contracts[index], allFlows.allChunkedFlows[index],  allFlows.paths[index].split(".").pop(), level, allFlows.paths[index], "detail", true, allFlows.aggregateCounts[index], allFlows.immediateChildren && allFlows.immediateChildren.length)
            })

        }

        {
            allAcctflows.accounts.forEach((flows, index)=>{
 
                appendFooter($tableEnd, allAcctflows.accounts[index], allAcctflows.allChunkedFlows[index], allAcctflows.paths[index])

            })

        }

        appendFooter($tableEnd,{unit:targetCurrency}, genAccountLine(allFlows.allFlows, start, end, {}, targetCurrency, windowSize) , "Totals")

        function createTable(windowedSeq) {
            $('#flows').empty();

            $('<div>').text("window:").append($input = $('<input>').val(windowSize).on('blur', (e) => {
                    windowSize = e.target.value;
                    refreshWindows()
                }))
                .appendTo($('#flows'))

            $('<div>').text("start:").append($input = $('<input>').val(start).on('blur', (e) => {
                    start = ""+e.target.value;
                    refreshWindows()
                }))
                .appendTo($('#flows'))

            $('<div>').text("end:").append($input = $('<input>').val(end).on('blur', (e) => {
                    end = ""+e.target.value;
                    refreshWindows()
                }))
                .appendTo($('#flows'))

            // $('<div>').text("targetAccounts:"+targetAccounts)
            //         .appendTo($('#flows'))

            $('<div>').text("currency:").append($('<input>').val(targetCurrency).on('blur', (e) => {
                    targetCurrency = e.target.value;
                    refreshWindows()
                }))
                .appendTo($('#flows'))

            let $table = $('<table>')
            $table.css("border", "1px solid #000");
            let $header = $('<tr>').appendTo(
                $table
                .appendTo($('#flows'))
            )

            $header
                .append($('<td>').text("+-").on("click", expandmax))
                .append($('<td>').text("name")
                    .css("border", "1px solid #000"));

            _.each(contractProto, (value, prop) => {
                if (value == null)
                    $header.append($('<td>').text(prop)
                        .css("border", "1px solid #000"));

            })
            _.each(windowedSeq, (wind, day) => {
                $header.append($('<td>').text(day.split('-')[0])
                    .css("border", "1px solid #000"));
            })

 
            return $table
        }

        function appendRow($appendPoint, targetContract, windowedFlows, contractName, level, path, cssClass, show, aggregateCount, hasChildren) {

            function toggle(e) {
                let $tr = $(this)
                let targetPath = $tr.data("path")
                let targetLevel = $tr.data("level")
                let targetIsDetail = $tr.hasClass("detail")
                let targetAggregateCount = $tr.data("aggregateCount")
                $('tr').each((index, tr) => {
                    let $tr = $(tr)
                    let myPath = $tr.data("path")
                    let myLevel = $tr.data("level")
                    let myIsDetail = $tr.hasClass("detail")
                    let myAggregateCount = $tr.data("aggregateCount")
                    if (myPath && myPath.startsWith(targetPath)) {
                        if (targetIsDetail) {
                            // if aggregate: collapse
                            if (targetAggregateCount>1) {
                                if  (myLevel==targetLevel && !myIsDetail)
                                    $tr.show() 
                                else if (myLevel>targetLevel) 
                                    $tr.hide() 
                                else if (myLevel==targetLevel  && myIsDetail) 
                                    $tr.hide() 

                            }
                            // else ignore

                                                           
                        } else { // tareget is Rollup/aggregate

                            if  (myLevel==targetLevel && myIsDetail)
                                $tr.show() 
                            else if (myLevel>targetLevel && myLevel<=targetLevel+1) {
                                if (myIsDetail) {
                                    if (myAggregateCount<=1)
                                        $tr.show() 
                                    else 
                                        $tr.hide() 
                                }
                                else { // is rollup
                                    if (myAggregateCount<=1)
                                        $tr.hide() 
                                    else 
                                        $tr.show() 
                                }

                            } 
                            else if (myLevel==targetLevel  && !myIsDetail) {
                                $tr.hide() 
                            }
                        }
                    }
                })

                // $tr
                //     .off("click", toggleHide)
                //     .on("click", toggleShow)

            }

            {

                let $tr = $('<tr>')
                    .data("path", path )
                    .data("level", level )
                    .data("aggregateCount", aggregateCount )
                    .data("hasChildren", aggregateCount )
                    .data("contract", targetContract )

                    .appendTo($appendPoint)
                    .on("click", toggle)
                    .addClass(cssClass)

                let symbol= "+"
                if (cssClass=='detail') {
                    if (aggregateCount>1)
                        symbol= "-"
                    else 
                        symbol= ""
                        
                } else {

                }
                $tr.append(
                    $('<td>')
                    .text(symbol)
                    .addClass('expand/collapse')
                )

                $tr.append($('<td>')
                    .text((contractName ? contractName : ""))
                    .css("padding-left", ' ' + (level * 10) + "px")
                    .css("border", "1px solid #000")
                );

                _.each(contractProto, (value, prop) => {
                    if (value == null) {
                        let $td;
                        $tr.append($td = $('<td>').text(targetContract[prop])
                            .css("border", "1px solid #000")
                            .css("padding-left", ' ' + (level * 10) + "px")
                        );
                        if (targetContract && targetContract.inherited && targetContract.inherited.indexOf(prop) != -1) {
                            $td.css("background-color", "lightgrey")
                        }
                    }
                })

                _.each(windowedFlows, (wind, day) => {
                    $tr.append($('<td>').text(wind.amount)
                        .css("border", "1px solid #000")
                        .css("padding-left", ' ' + (level * 10) + "px")
                    );
                })

                if (show)
                    $tr.show();
                else 
                    $tr.hide();
            }
        }

        function appendFooter($appendPoint, targetContract, windowedFlows, contractName) {

            let $tr = $('<tr>').appendTo($appendPoint).css("background-color", "yellow")

            $tr.append($('<td>').text(''))
            $tr.append($('<td>').text(contractName)
                .css("border", "1px solid #000"));
            _.each(contractProto, (value, prop) => {
                if (value == null)
                    $tr.append($('<td>').text(targetContract[prop])
                        .css("border", "1px solid #000"));

            })

            _.each(windowedFlows, (wind, day) => {
                let $td;
                $tr.append(
                    $('<td>')
                    .append($('<span>').text(wind.amount))
                    .append($('<br>'))
                    .append($bal = $('<span>').text(" (" + (wind.balance?wind.balance :'0') + ")"))
                    .css("border", "1px solid #000")
                );

                if (wind.oldBalance !== undefined) {
                    $bal.css("color", "black")
                    $bal.css("font-weight", "bold")
                }
            })

        }
    
   // expandmax()

    }

    $(refreshWindows)
    </script>

    <style type="text/css">
       .rollup { background-color :lightgrey;}
 /*        .detail { display: none; }
        .rollup { display: ''; }
        .detail { display: ''; }
*/

    </style>
</head>

<body>
    <div id="flows"> </div>
</body>

</html>