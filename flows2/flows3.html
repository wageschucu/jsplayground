<!DOCTYPE html>
<html>

<head>
    <meta charset="UTF-8">
    <title>Flows2</title>
    <!--     <script type="text/javascript" src="lazy.js"></script>
 -->
    <!-- optional: if you want support for DOM event and AJAX-based sequences: -->
    <!--     <script type="text/javascript" src="lazy.browser.js"></script>
 -->
    <script type="text/javascript" src="moment-with-locales.js"></script>
    <script type="text/javascript" src="lodash.js"></script>
    <!--     <script type="text/javascript" src="flows2.js"></script>
 -->
    <script type="text/javascript" src="jquery-3.2.1.js"></script>
    <script type="text/javascript">
    // todo: 
    // zoom in gestures: pop up with/jump to stack for one level of detail or 2 more: M -> w or -> day explode 
    //     https://www.w3schools.com/howto/howto_js_popup.asp
    // screen splitting a la excel 
    // gui jquery code redesign - collapse event handling!!

    let test=true

    // [accountNames],[all-flows]=> genAllAccountLines => [chunkFlows], Total-chunkedFlows
    function genAllAccountLines(accountNames, normalizedAcccounts, allFlows, start, end, unit, rythm) {
        // walk-contracts
        let result = { totalFlows: {}, allChunkedFlows: [], paths: [], accounts: [] }
        accountNames.forEach(accountName => {
            let account = findPropOnObject(accountName, normalizedAcccounts)
            let balances = findPropOnObject("balances", account)

            result.allChunkedFlows.push(genAccountLine(allFlows, start, end, balances, unit, rythm, accountName))
            result.paths.push(accountName)
            result.accounts.push(findPropOnObject(accountName, normalizedAcccounts))

        })
        return result
    }

    function getAllAccountNames(normalizedAcccounts) {
        let accountNames = []
        walkPojo(normalizedAcccounts, (account, name) => {
            if (!isAcccount(account)) return
            accountNames.push(name)
        })
        return accountNames
    }

    function isAcccount(account) {
        return account && account.balances !== undefined
    }

    function isContract(contract) {
        return contract && contract.amount !== undefined && contract.amount != 0 && contract.start !== undefined
    }
    // contracts,start,end => genAllContractLines => [all-chunkFlows],[all-flows]
    function genAllContractLines(normalizedContracts, start, end, rythm) {
        // walk-contracts
        let allResults = { allFlows: [], allChunkedFlows: [], allChunkedRowupFlows: [], paths: [], contracts: [], aggregateCounts: [], immediateChildren: [], hasDetail: [] }
        walkPojo(normalizedContracts, (contract, key, level, path, immediateChildren) => {
            if (!isContract(contract) && !immediateChildren) return
            let results = { allFlows: [], allChunkedFlows: [], allChunkedRowupFlows: [], paths: [], contracts: [], aggregateCounts: [] }
            let result = genContractLine(contract, start, end, rythm, immediateChildren)

            allResults.allFlows.unshift(result.flows)
            allResults.allChunkedFlows.unshift(result.chunkedFlows)
            allResults.allChunkedRowupFlows.unshift(result.chunkedRollupFlows)
            // rollup for each account, if there is subs 
            result.contract = contract;
            allResults.contracts.unshift(contract)
            result.path = path + (key ? key : "");

            allResults.paths.unshift(result.path)
            allResults.aggregateCounts.unshift(result.aggregateCount)
            allResults.immediateChildren.unshift(immediateChildren)
            allResults.hasDetail.unshift(result.hasDetail)

            return result.allFlows;
        })
        return allResults
    }

    // [all-flows],accountName,unit=>genAccountLine=>flows{windows:{ amount, unit, accounts, balance },...}
    function genAccountLine(allFlows, start, end, balances, unit, rythm, accountName) {

        let rolledUpFlows = genRollupFlows(start, end, allFlows, [accountName], unit)
        let actualFlows = actualizeFlows(rolledUpFlows, balances)
        let chunkedFlows = chunkFlows(start, end, actualFlows, rythm)
        return chunkedFlows
    }

    function genRollupFlows(start, end, allFlows, accountNames, unit) {
        let startOfFlows = _.chain(allFlows).values().head().keys().head().value()
        let rolledUpFlows = (startOfFlows && startOfFlows.split("-").length>1) 
            ?
             _.chain(allFlows).values().head().keys().reduce((flows, period)=>{ 
                flows[period]={}; 
                return flows; 
            }, {}).value() 
            : 
            genFlows(start, end, "d")
        
        if (allFlows) {
            allFlows.forEach(flows => {
                // filter out none listed accounts
                let flow = _.chain(flows).values().head().value()
                if (accountNames && accountNames.length && accountNames[0] !== undefined && !(flow && flow.account && accountNames.indexOf(flow.account) != -1))
                    return

                _.reduce(rolledUpFlows, (dummy, rollup, day) => {
                    rolledUpFlows[day] = mergeFlow(rollup, flows[day], unit)
                }, 1)
            })
        }
        return rolledUpFlows
    }

    // contract,start,end,unit,rythm=>genContractLine=>chunkFlows
    function genContractLine(normalizedContract, start, end, rythm, immediateChildren) {
        let result = {}
        result.flows = genFlows(start, end, null, normalizedContract)
        result.chunkedFlows = chunkFlows(start, end, result.flows, rythm)

        // fetch all from this contract down: flag when there are not sub contracts:?some null value 
        result.allFlows = immediateChildren || []
        result.allFlows.push(result.flows)
        let rollupFlows = genRollupFlows(start, end, result.allFlows, null, normalizedContract.unit)
        result.chunkedRollupFlows = chunkFlows(start, end, rollupFlows, rythm)
        let aggregateCount = immediateChildren && immediateChildren.length || 0
        result.aggregateCount = aggregateCount
        result.hasDetail = isContract(normalizedContract)
        return result
    }

    function parseRythm(rythm) {
        let res = { length: 1, rythm: "" }
        let a = rythm.split("-")
        if (a.length == 1)
            res.rythm = a[0]
        else {
            res.rythm = a[1]
            res.length = parseInt(a[0])
        }
        if (res.rythm == "y")
            console.log("found")
        return res
    }

    // contract,start,end,unit=>genFlows=>flows{day:{ amount, unit, account },...}
    function genFlows(start, end, rythm, normalizedContract) {
        let flows = {}
        if (normalizedContract && normalizedContract.start > start)
            start = normalizedContract.start
        if (normalizedContract && normalizedContract.end < end)
            end = normalizedContract.end
        if (normalizedContract && !rythm)
            rythm = normalizedContract && normalizedContract.rythm

        if (rythm) {
            let current = start
            let next;
            let parsedRythm = parseRythm(rythm)

            while (current <= end) {
                let flow = {}

                flow.amount = normalizedContract && normalizedContract.amount
                flow.unit = normalizedContract && normalizedContract.unit
                flow.account = normalizedContract && normalizedContract.account
                flows[current] = flow;

                for (i = 0; i < parsedRythm.length; i++) {
                    next = moment(current, 'YYYYMMDD').add(1, parsedRythm.rythm).format('YYYYMMDD')
                    if (next == current) { // in case moment duration/rythm code is incorrect:moment returns same date
                        throw "constant current date :" + current + " rythm: " + rythm
                    }
                    current = next;
                }
            }
        }
        return flows
    }


    // flows/actualFlows,rythm=>chunkFlows=>chunkedFlows{windows:{ amount, unit, accounts },...}
    // create window and gather flows and merge them
    function chunkFlows(start, last, flows, rythm) {
        let chunkedFlows = {}

        let current = start
        let next;

        // current and next: last-next-1-rythm

        while (current <= last) {
            next = moment(current, 'YYYYMMDD').add(1, rythm).format('YYYYMMDD')
            if (next == current) {
                throw "constant current date :" + current + " , rythm: " + rythm
            }
            let nextminusone = moment(next, 'YYYYMMDD').add(-1, "d").format('YYYYMMDD')
            let chunkName = current + "-" + nextminusone + "-" + rythm

            chunkedFlows[chunkName] = gatherAndMergeFlows(current, nextminusone, flows)

            current = next
        }
        return chunkedFlows
    }

    function gatherAndMergeFlows(start, last, flows) {
        let chunk = { flow: 0 }
        if (!flows) return chunk;

        let current = start
        while (current <= last) {
            chunk = mergeFlow(chunk, flows[current])
            next = moment(current, 'YYYYMMDD').add(1, "d").format('YYYYMMDD')
            current = next
        }
        return chunk
    }
    function mergeFlow(oldFlow, flow, unit) {
        let merged = {}
        merged.unit = unit || oldFlow.unit || flow && flow.unit
        // account : if diff to array
        if ((oldFlow && oldFlow.account && Array.isArray(oldFlow.account)) || (flow && flow.account && Array.isArray(flow.account)) || (flow && oldFlow && oldFlow.account && flow.account && oldFlow.account != flow.account)) {
            merged.account = []
            if (oldFlow && oldFlow.account && Array.isArray(oldFlow.account))
                merged.account = [...new Set([...merged.account, ...oldFlow.account])];
            else if (oldFlow.account)
                merged.account.push(oldFlow.account)

            if (flow && flow.account && Array.isArray(flow.account))
                merged.account = [...new Set([...merged.account, ...flow.account])];
            else if (flow && flow.account)
                merged.account.push(flow.account)

        } else {
            merged.account = oldFlow.account || flow && flow.account
        }

        merged.amount = oldFlow.amount || 0
        merged.in = oldFlow.in || 0
        merged.out = oldFlow.out || 0

        let newBalance = (flow && flow.balance) || (oldFlow && oldFlow.balance)
        if (newBalance !== undefined) {
            merged.balance = newBalance
        }

        newBalance = (flow && flow.oldBalance) || (oldFlow && oldFlow.oldBalance)
        if (newBalance !== undefined) {
            merged.oldBalance = newBalance
        }

        if (flow && flow.in) {
            let inamount=convert(flow.in, flow.unit, merged.unit)
            merged.in += inamount
            merged.in = Math.round(merged.in * 100) / 100
        }
         
        if (flow && flow.out) {
            let out=convert(flow.out, flow.unit, merged.unit)
            merged.out += out
            merged.out = Math.round(merged.out * 100) / 100
        }
         
        if (flow && flow.amount) {
            let amount=convert(flow.amount, flow.unit, merged.unit)
            merged.amount += amount
            merged.amount = Math.round(merged.amount * 100) / 100
            if (amount>0 && typeof flow.in === "undefined") {
                merged.in += amount
                merged.in = Math.round(merged.in * 100) / 100
            }
            else if ( typeof flow.out === "undefined") {
                merged.out += amount
                merged.out = Math.round(merged.out * 100) / 100
            }
        }

        if (flow && flow.negative || oldFlow && oldFlow.negative)
            merged.negative = flow.negative || oldFlow.negative

        return merged
    }

    function convert(value, unit, targetUnit) {
        if (unit && unit != targetUnit) {
            let factor = getConversionFactor(unit, targetUnit)
            value = value * factor
        }
        return value;
    }

    function getConversionFactor(unit, targetUnit) {
        if (units[unit][targetUnit])
            return units[unit][targetUnit]
        else
            throw new Error("no conversion for : " + unit + " to " + targetUnit)
    }
    // flows,account:{balances,unit,...}=>actualizeFlows=>actualFlows{day:{ amount, unit, account, balance, oldBalance,.. },...}
    function actualizeFlows(flows, balances) {
        let balance = 0
        _.reduce(flows, (flows, flow, day) => {
            if (flow.amount !== undefined)
                balance += flow.amount
            flow.balance = balance
            if (balances[day] !== undefined) {
                flow.oldBalance = flow.balance
                flow.balance = balances[day]
                balance = balances[day]
            }
            if (flow.balance < 0) {
                flow.negative = flow.negative || {}
                flow.negative[day] = flow.balance
            }
            return flows
        }, flows)

        return flows
    }

    function findPropOnObject(prop, source) {
        for (var property in source) {
            let found = undefined
            if (prop == property) {
                found = source[property];
            } else if (typeof source[property] === "object") {
                found = findPropOnObject(prop, source[property]);
            }
            if (found)
                return found
        }
        return undefined
    }

    function normalizeAmount(contract) {
        // set start
        // norm start
        if (!contract.amount)
            return
        contract.amount = -contract.amount
    }

    function normalizeTransfers(contracts) {

        return function(contract, key, level, path) {
            if (!contract.contract)
                return
            let transferContract =
                _(path.split("."))
                .filter(elem => elem)
                .unshift(contract.contract)
                .push(key)
                .reduce((current, pathElement) => {
                    current[pathElement] = current[pathElement] || {};
                    return current[pathElement]
                }, contracts)
            clone(contract, true, transferContract)
            transferContract.amount = -transferContract.amount
            transferContract.contract = undefined
            transferContract.account = transferContract.transferAccount || transferContract.account
            transferContract.transferAccount = undefined
        }
    }

    function normalizeDates(contract) {
        // set start
        // norm start
        if (!contract.start)
            return
        normalizeDate(contract, "start")
        normalizeDate(contract, "end")
    }

    function normalizeDate(contract, prop) {
        // set start
        // norm start
        let date = contract[prop];
        if (date) {
            let endMarker = "end"
            if (date.indexOf(endMarker) == date.length - endMarker.length) {
                if (date.length != 6 + endMarker.length)
                    throw "date not YYYYMM formate: " + JSON.stringify(contract, null, 2)
                let begin = moment(date.substring(0, 6), 'YYYYMM')
                let end = begin.endOf('month');
                contract[prop] = end.format('YYYYMMDD')
            }
        }
    }

    function normaliseContracts(contracts, contractProto) {
        contracts = inherit(contracts, {}, contractProto, true)
        walkPojo(contracts, normalizeDates)
        walkPojo(contracts, normalizeAmount)
        walkPojo(contracts, normalizeTransfers(contracts))
        return contracts
    }

    // bring last balance before start day forward, if start day does not have balance ??
    // go down balances until >= start day, if start day not defined and there is one before copy it in on start day
    function bringFowardOldBalance(account, accountName) {
        // find last balance before start
        if (!isAcccount(account)) return
        if (account.balances && !account.balances[start]) {

            let last = _(account.balances).reduce((found, balance, day) => {
                if (day < start) {
                    return { day: day, balance: balance }
                }
                return found
            }, {})
            if (last && last.day) {
                // calc flows,balance until start
                let allFlows = genAllContractLines(normalisedContracts, last.day, start, 'd')

                let rolledUpFlows = genRollupFlows(last.day, start, allFlows.allFlows, [accountName], account.unit)
                    
                let bals = {}
                bals[last.day] = last.balance
                let actualFlows = actualizeFlows(rolledUpFlows, bals)
                let end = _.findLastKey(actualFlows)
                // copy start balance to balances
                account.balances[start] = actualFlows[end].balance
            }
        }
    }
    function isTransfer(transfers, property) { return property=="transfers"}

    function normaliseAccounts(accounts, start, end, normalisedContracts, prototypeAccount) {

        let normalizedAcccounts = inherit(accounts, {}, prototypeAccount, true);

        walkPojo(normalizedAcccounts, bringFowardOldBalance)
        walkPojo(normalizedAcccounts, implementTransfers)

        function implementTransfers(transfers, property, level, path, res) {
            if (!isTransfer(transfers, property)) return 
            _.each(transfers, transfer=>{
                let toAccount=transfer.account
                let fromAccount=_.findLast(path.split("."))
                // create contracts: transfers.accountfrom, transfers.accountto
                normalisedContracts.transfers=normalisedContracts.transfers || {}
                normalisedContracts.transfers[toAccount] = normalisedContracts.transfers[toAccount] || {}
                let index = _.keys(normalisedContracts.transfers[toAccount]).length
                normalisedContracts.transfers[toAccount][index] = clone(transfer, true)

                normalisedContracts.transfers[fromAccount] = normalisedContracts.transfers[fromAccount] || {}
                index = _.keys(normalisedContracts.transfers[fromAccount]).length
                normalisedContracts.transfers[fromAccount][index] = clone(transfer, true)

                normalisedContracts.transfers[fromAccount][index].amount = -transfer.amount
                normalisedContracts.transfers[fromAccount][index].account = fromAccount

            
            })
        }

        return normalizedAcccounts
    }
    // deep copy of undefined attributes
    function inherit(source, parent, prototype, deep) {
        // filter parent 
        let target = {}

        // copy source props
        //   if prop in prototype: deep copy/clone 
        for (var prop in source) {
            if (prototype[prop] !== undefined) {
                if (typeof source[prop] == "object") {
                    target[prop] = clone(source[prop], true)
                } else {
                    target[prop] = source[prop]
                }
            }
        }

        // inheit from parent
        for (var prop in parent) {
            if (prototype[prop] === null && target[prop] === undefined && parent[prop] !== undefined) {
                target[prop] = parent[prop]
                if (prototype.inherited) {
                    target.inherited = target.inherited || []
                    target.inherited.push(prop)
                }
            }
        }

        for (var prop in source) {
            if (prototype[prop] === undefined && typeof source[prop] == "object") {
                if (deep)
                    target[prop] = inherit(source[prop], target, prototype, deep)
                else
                    target[prop] = source[prop]
            }
        }

        return target
    }

    // deep copy, but not overwriting dest leaves
    function clone(source, deep, destination) {
        if (!destination)
            destination = {}
        for (var property in source) {
            if (typeof source[property] === "object" && deep) {
                if (Array.isArray(source[property]))
                    destination[property] = []
                else
                    destination[property] = {}
                clone(source[property], deep, destination[property]);
            } else {
                destination[property] = source[property];
            }
        }
        return destination
    }

    function walkPojo(source, iterator, key, level, path) {

        if (level === undefined)
            level = 0
        if (path === undefined)
            path = "."
        let subPath = path
        if (key)
            subPath += key + "."
        let res;
        for (var property in source) {
            if (typeof source[property] === "object") {
                let subres = walkPojo(source[property], iterator, property, level + 1, subPath)
                if (subres !== undefined)
                    res = (res || []).concat(Array.isArray(subres) ? subres : [subres])
            }
        }
        res = iterator(source, key, level, path, res)
        if (res !== undefined && !Array.isArray(res))
            res = [res]
        return res
    }

    Set.prototype.toJSON = function toJSON() {
        return [...Set.prototype.values.call(this)];
    }

    // function pluckMergeArrays(array,  property) {
    //     let res=[];
    //     if (array && Array.isArray(array)) {
    //         array.forEach(item=> { 
    //             res=res.concat(item && Array.isArray(item[property]) && item[property]|| [])
    //         }) }
    //     return res;
    // }


    const contractProto = {
        start: null,
        duration: null,
        end: null,
        amount: null,
        account: null,
        rythm: null,
        flows: [],
        unit: null,
        inherited: [],
        contract: "",
        transferAccount: ""
    }
    const prototypeAccount = {
        unit: null,
        balances: [],
        inherited: [],
        transfers:[]
    }
    </script>
    <script type="text/javascript">
    var allflowsg;
    const accounts = {
        post: {
            unit: "chf",
            zahlungs: {
                balances: {
                    '20160101': 1000,
                    '20161101': 2000,
                    '20170101': 9000,
                },
                // transfer
                transfers: [{ account:"monthly", start: 20170101, rythm: "M",  amount: 400 },
                    { account:"spar", start: 20170101, rythm: "M",  amount: 2000 },],
            },
            monthly: {
                balances: {
                    '20171031': 100,
                },
                // transfer??
                //spar: { start: 20170101, rythm: "M",  amount: 1000 },
            },

            usd: {
                unit: "usd",
                balances: {
                    '20170101': 1000,
                }
            },
            eur: {
                unit: "eur",
                balances: {
                    '20170101': 10,
                }
            },
            spar: {
                balances: {
                    '20170101': 100,
                }
            },
            "3a": {
                balances: {
                    '20170101': 27000,
                }
            }
        },
        tnb: {
            unit: "usd",
            checking: {
                balances: {
                    '20170101': 10000,
                }
            },
            savings: {
                balances: {
                    '20170101': 2000,
                }
            }
        }
    }
    const testAccounts = {
        post: {
            unit: "chf",
            zahlungs: {
                balances: {
                    '20160101': 0,
                    '20171031': 0,
                },
            },
        },
    }

    const units = {
        chf: { eur: 1 / 1.2, usd: 1.1 },
        eur: { chf: 1.2, usd: 1.1 },
        usd: { eur: 1 / 1.1, chf: 1 / 1.1 }
    }

    // Key  Shorthand
    // years    y
    // quarters Q
    // months   M
    // weeks    w
    // days d
    // hours    h
    // minutes  m
    // seconds  s
    // milliseconds ms
    let contracts = {
        account: "zahlungs",
        unit: "chf",
        rythm: "M",
        start: "20160101",

        ruckbildungen: {
            account: "spar",
        },
        transfers : {},
        apartment: {
            "miete": {
                amount: 1700,
            },
            utils: {
                amount: 150,
            },
            elect: {
                amount: 150,
                rythm: "Q",
            },
            cleaning: {
                amount: 75,
                rythm: "w",
                supplies: {
                    amount: 25,
                    rythm: "M",
                    account:"monthly",
                },
            },
            insurance: {
                rythm: "y",
                haftpflicht: {
                    amount: 150,
                },
                hausrat: {
                    amount: 250,
                },
            },
        },
        health: {
            kk: {
                amount: 400,
                rythm: "M",
                francise: {
                    start: "20160301",
                    amount: 300,
                    rythm: "y"
                },
                copay: {
                    amount: 30,
                },
            },
            alternative: {
                amount: 50,
                rythm: "M",
                account:"monthly",
            },
        },
        income: {
            lohn: {
                amount: -9000,
                rythm: "M",
                start: "20170131",
                bonus: {
                    amount: -9000,
                    rythm: "y",
                    start: "20171231",
                },
            },
            us: {
                account: "checking",
                tnb: {
                    amount: -1000,
                    rythm: "Q",
                    start: "20160331",
                    yearend: {
                        amount: -3000,
                        rythm: "y",
                        start: "201712301",
                    },
                },
                farm: {
                    amount: -25000,
                    rythm: "y",
                    start: "20171231",
                },
            }
        },
        entertainmenttravel: {
            vacation: {
                amount: 1000,
                start: "20170701",
                rythm: "y",
            },
        },
        food: {},
        olivia: {
            kk: {
                amount: 80,
                rythm: "M",
                francise: {
                    start: "20160301",
                    amount: 0,
                    rythm: "y"
                },
                copay: {
                    amount: 0,
                },
            },
            school: {
                amount: 1100,
                rythm: "M",
            },
            transport: {
                amount: 60,
                rythm: "M",
            },
            clothes: {
                amount: 50,
                rythm: "Q",
            },

        },
        auto: {
            gas: {
                account:"monthly",
                amount: 100,
            },
            vinette: {
                start: "20161201",
                rythm: "y",                
                account:"monthly",
                amount: 40,
            },
            insurance: {
                kaskoetc: {
                    amount: 100,
                },
                garanteeextension: {
                    amount: 100,
                },
            },
            oil: {
                amount: 100,
            },
            service: {
                amount: 100,
            },
            amortisation: {
                contract: "ruckbildungen",
                amount: 250,
                transferAccount: "spar"
            },
            tires: {
                rotation: {
                    amount: 100,
                },
                replacement: {
                    amount: 100,
                },
            },
            replacement: {
                start: "20221231",
                rythm: "5-y",
                account: "spar",
                sell: {
                    amount: -15000,
                },
                buy: {
                    amount: 30000,
                },
            },
        }
    }

    let testContracts = {
        account: "zahlungs",
        unit: "chf",
        rythm: "M",
        start: "20160101",
        auto: {
            amount: 150,
            parking: {
                amount: 100,
                parking2: {
                    amount: 0,
                    parking3: {
                        amount: 10,
                    },
                    parking4: {
                        amount: 5,
                    },
                    income: {
                        amount: -100,
                    },
                    income2: {
                        amount: -50,
                    },
                },
            },
        },
    }

    let start = '20170101'
    let end = '20171231'
    let windowSize = "M"

    //let targetAccounts = ["zahlungs", "checking", "spar"]
    let targetCurrency = "chf"

    let normalisedContracts = (test)?normaliseContracts(testContracts, contractProto):normaliseContracts(contracts, contractProto)

    let normalizedAcccounts = (test)?normaliseAccounts(testAccounts, start, end, normalisedContracts, prototypeAccount):normaliseAccounts(accounts, start, end, normalisedContracts, prototypeAccount)


    // console.log(JSON.stringify(allAcctflows, null, 2))

    // gen all contracts: if dates or rythm change
    // gen all accounts: if above or unit change
    // refresh/redraw, generate, loop contracts, expand logic, css, 
    // budget examples, mine, a house?, retirement 
    // expand path, max/one level
    //   if below expanding: has children&&contract? show detail: show aggregate
    // 
    function collapse() {
        let $tr = $(this).closest('tr')
        let path = $tr.data("path")

        $('tr').each((index, tr) => {
            let $tr = $(tr)
            let myPath = $tr.data("path")

            if (path && (!myPath || !myPath.startsWith(path))) return

            let myIsDetail = $tr.hasClass("detail")
            let contract = $tr.data("contract")
            let hasChildren = $tr.data("aggregateCount")
            let hasDetail = $tr.data("hasDetail")

            let show = false
            // if equal paths
            // if has no children and has detail, show detail
            // else show rollup
            if (myPath == path) {
                if (myIsDetail && !hasChildren && hasDetail)
                    show = true
                else if (!myIsDetail && hasChildren)
                    show = true
                else
                    show = false
            } else
                show = false

            if (show)
                addExpandHandler($tr, expandone, "+")

            if (show)
                $tr.show();
            else
                $tr.hide()
        })
        removeExpandHandler($tr, collapse, "-")

    }

    function expandmax() {
        let $tr = $(this).closest('tr')
        let path = $tr.data("path")

        $('tr').each((index, tr) => {
            let $tr = $(tr)
            let myPath = $tr.data("path")
            let hasChildren = $tr.data("aggregateCount")

            if (path && (!myPath || !myPath.startsWith(path))) return

            let myIsDetail = $tr.hasClass("detail")
            let contract = $tr.data("contract")

            let show = false
            if (myIsDetail && isContract(contract))
                show = true
            else if (!myIsDetail && !isContract(contract))
                show = true
            else
                show = false

            let isLeaf = myIsDetail && !hasChildren
            if (show && !isLeaf)
                addExpandHandler($tr, collapse, "-")

            if (show)
                $tr.show();
            else
                $tr.hide()
        })
        removeExpandHandler($tr, expandmax)

    }

    function expandone(levelsIn) {
        let levels = typeof levelsIn === "number" ? levelsIn:1
        let $tr = $(this).closest('tr')
        let path = $tr.data("path")
        let level = $tr.data("level")
        if (level === undefined) level = 0
        if (!path) path = "."

        $('tr').each((index, tr) => {
            let $tr = $(tr)
            let myPath = $tr.data("path")

            if (path && (!myPath || !myPath.startsWith(path))) return

            let myIsDetail = $tr.hasClass("detail")
            let myLevel = $tr.data("level")
            let contract = $tr.data("contract")
            let myIsContract = isContract(contract)
            let hasChildren = $tr.data("aggregateCount")

            let show = false
            if (myIsDetail && myIsContract && (level <= myLevel && level + levels >= myLevel))
                show = true
            else if (!myIsDetail && !myIsContract && (level <= myLevel && level + levels >= myLevel))
                show = true
            else
                show = false
            let isLeaf = myIsDetail && !hasChildren
            if (!isLeaf) {
                if (show && (level <= myLevel && level + levels > myLevel))
                    addExpandHandler($tr, expandmax, "++")
                if (show && level + levels == myLevel)
                    addExpandHandler($tr, expandone, "+")
            }

            if (show)
                $tr.show();
            else
                $tr.hide()
        })
        removeExpandHandler($tr, expandone)

    }

    function addExpandHandler($tr, handler, symbol) {
        $('td', $tr).first().on("click", handler).text(symbol)

    }

    function removeExpandHandler($tr, handler) {
        $('td', $tr).first().off("click", handler)
    }

    function mergeFlows(flows) {
        return _.reduce(flows, (merged, flow, day) => {
            return mergeFlow(merged, flow)
        },{})
    }

    function refreshWindows() {

        let allFlows = genAllContractLines(normalisedContracts, start, end, windowSize)
        allflowsg = allFlows
        let allAccountNames = getAllAccountNames(normalizedAcccounts)
        let allAcctflows = genAllAccountLines(allAccountNames, normalizedAcccounts, allFlows.allFlows, start, end, targetCurrency, windowSize)

        let $tableEnd = createTable(chunkFlows(start, end, null, windowSize));

        {
            allFlows.allFlows.forEach((flows, index) => {
                let level = (allFlows.paths[index].match(/\./g) || []).length;
                if (allFlows.paths[index].length == 1)
                    level = 0;

                appendRow($tableEnd, allFlows.contracts[index], allFlows.allChunkedRowupFlows[index],mergeFlows( allFlows.allChunkedRowupFlows[index]), allFlows.paths[index].split(".").pop(), level, allFlows.paths[index], "rollup", true, allFlows.aggregateCounts[index], allFlows.immediateChildren && allFlows.immediateChildren.length, allFlows.hasDetail[index])

                appendRow($tableEnd, allFlows.contracts[index], allFlows.allChunkedFlows[index],mergeFlows(allFlows.allChunkedFlows[index]), allFlows.paths[index].split(".").pop(), level, allFlows.paths[index], "detail", true, allFlows.aggregateCounts[index], allFlows.immediateChildren && allFlows.immediateChildren.length, allFlows.hasDetail[index])
            })
        }

        {
            allAcctflows.accounts.forEach((flows, index) => {

                appendFooter($tableEnd, allAcctflows.accounts[index], allAcctflows.allChunkedFlows[index], mergeFlows(allAcctflows.allChunkedFlows[index]), allAcctflows.paths[index])

            })

        }
        let totalFlows = genRollupFlows(start, end, allAcctflows.allChunkedFlows, undefined, targetCurrency) 

        // let totalFlows = genAccountLine(allflowsg.allFlows, start, end, {}, targetCurrency, windowSize)
        appendFooter($tableEnd, { unit: targetCurrency }, totalFlows, mergeFlows(totalFlows), "Totals", true )

        function createTable(windowedSeq) {
            $('#flows').empty();

            $('<div>').text("window:").append($input = $('<input>').val(windowSize).on('blur', (e) => {
                    windowSize = e.target.value;
                    refreshWindows()
                }))
                .appendTo($('#flows'))

            $('<div>').text("start:").append($input = $('<input>').val(start).on('blur', (e) => {
                    start = "" + e.target.value;
                    refreshWindows()
                }))
                .appendTo($('#flows'))

            $('<div>').text("end:").append($input = $('<input>').val(end).on('blur', (e) => {
                    end = "" + e.target.value;
                    refreshWindows()
                }))
                .appendTo($('#flows'))

            // $('<div>').text("targetAccounts:"+targetAccounts)
            //         .appendTo($('#flows'))

            $('<div>').text("currency:").append($('<input>').val(targetCurrency).on('blur', (e) => {
                    targetCurrency = e.target.value;
                    refreshWindows()
                }))
                .appendTo($('#flows'))

            let $table = $('<table>')
            $table.css("border", "1px solid #000");
            let $header = $('<tr>').appendTo(
                $table
                .appendTo($('#flows'))
            )

            $header
                .append($('<td>').text("+-").on("click", expandmax))
                .append($('<td>').text("name")
                    .css("border", "1px solid #000"));

            _.each(contractProto, (value, prop) => {
                if (value == null)
                    $header.append($('<td>').text(prop)
                        .css("border", "1px solid #000"));

            })
            _.each(windowedSeq, (wind, day) => {
                $header.append($('<td>').text(day.split('-')[0])
                    .css("border", "1px solid #000"));
            })
            $header.append($('<td>').text("Total")
                .css("border", "1px solid #000"));


            return $table
        }

        function appendRow($appendPoint, targetContract, windowedFlows, total, contractName, level, path, cssClass, show, aggregateCount, hasChildren, hasDetail) {

            let $tr = $('<tr>')
                .data("path", path)
                .data("level", level)
                .data("aggregateCount", aggregateCount)
                .data("hasChildren", aggregateCount)
                .data("contract", targetContract)
                .data("hasDetail", hasDetail)
                .appendTo($appendPoint)
                //.on("click", toggle)
                .addClass(cssClass)

            let factor=30
            let offset=130
            $tr.css("background-color","rgb(" + (offset+level*factor) + "," + (offset+level*factor) + "," + (offset+level*factor) + ")")

            let symbol = "+"
            if (cssClass == 'detail') {
                if (aggregateCount > 1)
                    symbol = "-"
                else
                    symbol = ""

            } else {

            }
            $tr.append(
                $('<td>')
                .text(symbol)
                .addClass('expand/collapse')
            )

            $tr.append($('<td>')
                .text((contractName ? contractName : ""))
                .css("padding-left", ' ' + (level * 10) + "px")
                .css("border", "1px solid #000")
            );

            _.each(contractProto, (value, prop) => {
                if (value == null) {
                    let $td;
                    $tr.append($td = $('<td>').text(targetContract[prop])
                        .css("border", "1px solid #000")
                        .css("padding-left", ' ' + (level * 10) + "px")
                    );
                    if (targetContract && targetContract.inherited && targetContract.inherited.indexOf(prop) != -1) {
                        $td.css("background-color", "lightgrey")
                    }
                }
            })

            if (cssClass == 'detail') 
                _.each(windowedFlows, (wind, day) => {
                    $tr.append($('<td>')
                       .append($('<span>').text(wind.amount))
                        .css("border", "1px solid #000")
                        .css("padding-left", ' ' + (level * 10) + "px")
                    );
                })
                else
                _.each(windowedFlows, (wind, day) => {
                    $tr.append($('<td>')
                        .append($('<span>').text(wind.in))
                        .append($('<br>'))
                        .append($('<span>').text(wind.out))
                        .append($('<br>'))
                       .append($('<span>').text(wind.amount))
                        .css("border", "1px solid #000")
                        .css("padding-left", ' ' + (level * 10) + "px")
                    );
                })

            if (cssClass == 'detail') 
                _.each([total], (wind, day) => {
                    $tr.append($('<td>')
                       .append($('<span>').text(wind.amount))
                        .css("border", "1px solid #000")
                        .css("padding-left", ' ' + (level * 10) + "px")
                        .css("background-color", "white")
                    );
                })
                else
                _.each([total], (wind, day) => {
                    $tr.append($('<td>')
                        .append($('<span>').text(wind.in))
                        .append($('<br>'))
                        .append($('<span>').text(wind.out))
                        .append($('<br>'))
                       .append($('<span>').text(wind.amount))
                        .css("border", "1px solid #000")
                        .css("padding-left", ' ' + (level * 10) + "px")
                        .css("background-color", "white")
                    );
                })

            if (show)
                $tr.show();
            else
                $tr.hide();

        }

        function appendFooter($appendPoint, targetContract, windowedFlows, total, contractName, isTotalLine) {

            let $tr = $('<tr>').appendTo($appendPoint)
    
            if (isTotalLine)
                $tr .css("background-color", "white")
            else
                $tr .css("background-color", "yellow")

            $tr.append($('<td>').text(''))
            $tr.append($('<td>').text(contractName)
                .css("border", "1px solid #000"));
            _.each(contractProto, (value, prop) => {
                if (value == null)
                    $tr.append($('<td>').text(targetContract[prop])
                        .css("border", "1px solid #000"));

            })

            _.each(windowedFlows, (wind, day) => {
                let $td;
                $tr.append(
                    $('<td>')
                    .append($('<span>').text(wind.in))
                    .append($('<br>'))
                    .append($('<span>').text(wind.out))
                    .append($('<br>'))
                    .append($('<span>').text(wind.amount))
                    .append($('<br>'))
                    .append($bal = $('<span>').text(" (" + (wind.balance ? wind.balance : '0') + ")"))
                    .css("border", "1px solid #000")
                );

                if (wind.oldBalance !== undefined) {
                    $bal.css("color", "black")
                    $bal.css("font-weight", "bold")
                }

                if (wind.negative !== undefined) {
                    $bal.css("color", "red")
                    $bal.css("font-weight", "bold")
                }
            })

            _.each([total], (wind, day) => {
                let $td;
                $tr.append(
                    $('<td>')
                    .append($('<span>').text(wind.in))
                    .append($('<br>'))
                    .append($('<span>').text(wind.out))
                    .append($('<br>'))
                    .append($('<span>').text(wind.amount))
                    .append($('<br>'))
                    .append($bal = $('<span>').text(" (" + (wind.balance ? wind.balance : '0') + ")"))
                    .css("border", "1px solid #000")
                    .css("background-color", "white")
                );

                if (wind.oldBalance !== undefined) {
                    $bal.css("color", "black")
                    $bal.css("font-weight", "bold")
                }

                if (wind.negative !== undefined) {
                    $bal.css("color", "red")
                    $bal.css("font-weight", "bold")
                }
            })

        }

        expandone(2)

    }

    $(refreshWindows)
    </script>
    <style type="text/css">
    .rollup {
          font-weight: bold;
    }
    .detail {     
        text-decoration: underline;
    }
    /*        .detail { display: none; }
        .rollup { display: ''; }
        .detail { display: ''; }
*/
    </style>
</head>

<body>
    <div id="flows"> </div>
</body>

</html>