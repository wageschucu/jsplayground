<!DOCTYPE html>
<html>

<head>
    <meta charset="UTF-8">
    <title>Flows3</title>
    <!--     <script type="text/javascript" src="lazy.js"></script>
 -->
    <!-- optional: if you want support for DOM event and AJAX-based sequences: -->
    <!--     <script type="text/javascript" src="lazy.browser.js"></script>
 -->
    <script type="text/javascript" src="moment-with-locales.js"></script>
    <script type="text/javascript" src="lodash.js"></script>
    <!--     <script type="text/javascript" src="flows2.js"></script>
 -->
    <script type="text/javascript" src="jquery-3.2.1.js"></script>
    <script type="text/javascript" src="/Users/paulgettel/Dropbox/data.js"></script>
    <script type="text/javascript">
    // todo: 
    // zoom in gestures: pop up with/jump to stack for one level of detail or 2 more: M -> w or -> day explode 
    // balance differences show: flag when above threshold: flag all the account contracts
    // separate into files
    // filter like data tables?? at least on account
    // manual refresh button
    // work on color, font, ux coding of structure of display
    // add file load button and saving of last path to local storage 
    //     https://www.w3schools.com/howto/howto_js_popup.asp
    // gui jquery code redesign - collapse event handling!!

    // [accountNames],[all-flows]=> genAllAccountLines => [chunkFlows], Total-chunkedFlows
    function genAllAccountLines(accountNames, normalizedAcccounts, allFlows, start, end, unit, rythm) {
        // walk-contracts
        let result = { totalFlows: {}, allChunkedFlows: [], paths: [], accounts: [] }
        accountNames.forEach(accountName => {
            let account = findPropOnObject(accountName, normalizedAcccounts)
            let balances = findPropOnObject("balances", account)

            result.allChunkedFlows.push(genAccountLine(allFlows, start, end, balances, unit, rythm, accountName))
            result.paths.push(accountName)
            result.accounts.push(findPropOnObject(accountName, normalizedAcccounts))

        })
        return result
    }


    function getAllAccountNames(normalizedAcccounts) {
        let accountNames = []
        walkPojo(normalizedAcccounts, (account, name) => {
            if (!isAcccount(account)) return
            accountNames.push(name)
        })
        return accountNames
    }

    function isAcccount(account) {
        return account && account.balances !== undefined
    }

    function isContract(contract) {
        return contract && contract.amount !== undefined && contract.amount != 0 && contract.start !== undefined
    }
    // contracts,start,end => genAllContractLines => [all-chunkFlows],[all-flows]
    function genAllContractLines(normalizedContracts, start, end, rythm) {
        // walk-contracts
        let allResults = { allFlows: [], allChunkedFlows: [], allChunkedRowupFlows: [], paths: [], contracts: [], aggregateCounts: [], immediateChildren: [], hasDetail: [] }
        walkPojo(normalizedContracts, (contract, key, level, path, immediateChildren) => {
            if (!isContract(contract) && !immediateChildren) return
            let results = { allFlows: [], allChunkedFlows: [], allChunkedRowupFlows: [], paths: [], contracts: [], aggregateCounts: [] }
            let result = genContractLine(contract, start, end, rythm, immediateChildren)

            allResults.allFlows.unshift(result.flows)
            allResults.allChunkedFlows.unshift(result.chunkedFlows)
            allResults.allChunkedRowupFlows.unshift(result.chunkedRollupFlows)
            // rollup for each account, if there is subs 
            result.contract = contract;
            allResults.contracts.unshift(contract)
            result.path = path + (key ? key : "");

            allResults.paths.unshift(result.path)
            allResults.aggregateCounts.unshift(result.aggregateCount)
            allResults.immediateChildren.unshift(immediateChildren)
            allResults.hasDetail.unshift(result.hasDetail)

            return result.allFlows;
        })
        return allResults
    }

    // [all-flows],accountName,unit=>genAccountLine=>flows{windows:{ amount, unit, accounts, balance },...}
    function genAccountLine(allFlows, start, end, balances, unit, rythm, accountName) {

        let rolledUpFlows = genRollupFlows(start, end, allFlows, [accountName], unit)
        let actualFlows = actualizeFlows(rolledUpFlows, balances)
        let chunkedFlows = chunkFlows(start, end, actualFlows, rythm)
        return chunkedFlows
    }

    function genRollupFlows(start, end, allFlows, accountNames, unit) {
        let startOfFlows = _.chain(allFlows).values().head().keys().head().value()
        let rolledUpFlows = (startOfFlows && startOfFlows.split("-").length > 1) ?
            _.chain(allFlows).values().head().keys().reduce((flows, period) => {
                flows[period] = {};
                return flows;
            }, {}).value() :
            genFlows(start, end, "d")

        if (allFlows) {
            allFlows.forEach(flows => {
                // filter out none listed accounts
                let flow = _.chain(flows).values().head().value()
                if (accountNames && accountNames.length && accountNames[0] !== undefined && !(flow && flow.account && accountNames.indexOf(flow.account) != -1))
                    return

                _.reduce(rolledUpFlows, (dummy, rollup, day) => {
                    rolledUpFlows[day] = mergeFlow(rollup, flows[day], unit)
                }, 1)
            })
        }
        return rolledUpFlows
    }

    // contract,start,end,unit,rythm=>genContractLine=>chunkFlows
    function genContractLine(normalizedContract, start, end, rythm, immediateChildren) {
        let result = {}
        result.flows = genFlows(start, end, null, normalizedContract)
        result.chunkedFlows = chunkFlows(start, end, result.flows, rythm)

        // fetch all from this contract down: flag when there are not sub contracts:?some null value 
        result.allFlows = immediateChildren || []
        result.allFlows.push(result.flows)
        let rollupFlows = genRollupFlows(start, end, result.allFlows, null, normalizedContract.unit)
        result.chunkedRollupFlows = chunkFlows(start, end, rollupFlows, rythm)
        let aggregateCount = immediateChildren && immediateChildren.length || 0
        result.aggregateCount = aggregateCount
        result.hasDetail = isContract(normalizedContract)
        return result
    }

    function parseRythm(rythm) {
        let res = { length: 1, rythm: "" }
        let a = rythm.split("-")
        if (a.length == 1)
            res.rythm = a[0]
        else {
            res.rythm = a[1]
            res.length = parseInt(a[0])
        }
        if (res.rythm == "y")
            console.log("found")
        return res
    }

    // function parseRythmPeriod(rythm, current, period) {
    //     let parsedRythm = parseRythm(rythm)
    //     return  rythmNextPeriod(parsedRythm, current, period) 
    // }

    // function rythmNextPeriod(parsedRythm, current, period) {

    //     for (j = 0; j < period; j++) {
    //         current = rythmNext(parsedRythm, current)
    //     }
    //     return current
    // }

    function rythmNext(parsedRythm, current) {

        for (i = 0; i < parsedRythm.length; i++) {
            let next
            if (parsedRythm.rythm=="o") {
                next="99991231"
            }
            else {
                next = moment(current, 'YYYYMMDD').add(1, parsedRythm.rythm).format('YYYYMMDD')
            }
            if (next == current) { // in case moment duration/rythm code is incorrect:moment returns same date
                throw "constant current date :" + current + " rythm: " + rythm
            }
            current = next;
        }
        return current
    }

    // contract,start,end,unit=>genFlows=>flows{day:{ amount, unit, account },...}
    function genFlows(start, end, rythm, normalizedContract) {
        let flows = {}
        let contractStart = start
        let contractEnd = end
        if (normalizedContract && normalizedContract.start)
            contractStart = normalizedContract.start
        if (normalizedContract && normalizedContract.end)
            contractEnd = normalizedContract.end
        if (normalizedContract && !rythm)
            rythm = normalizedContract && normalizedContract.rythm

        end = contractEnd < end ? contractEnd : end
        start = contractStart

        if (rythm) {
            let current = contractStart
            let next;
            let parsedRythm = parseRythm(rythm)

            while (current <= end) {
                if (start <= current) {
                    let flow = {}

                    flow.amount = normalizedContract && normalizedContract.amount
                    flow.unit = normalizedContract && normalizedContract.unit
                    flow.account = normalizedContract && normalizedContract.account
                    flows[current] = flow;
                }
                current=rythmNext(parsedRythm, current)
            }
        }
        return flows
    }


    // flows/actualFlows,rythm=>chunkFlows=>chunkedFlows{windows:{ amount, unit, accounts },...}
    // create window and gather flows and merge them
    function chunkFlows(start, last, flows, rythm) {
        let chunkedFlows = {}

        let current = start
        let next;

        // current and next: last-next-1-rythm

        while (current <= last) {
            next = moment(current, 'YYYYMMDD').add(1, rythm).format('YYYYMMDD')
            if (next == current) {
                throw "constant current date :" + current + " , rythm: " + rythm
            }
            let nextminusone = moment(next, 'YYYYMMDD').add(-1, "d").format('YYYYMMDD')
            let chunkName = current + "-" + nextminusone + "-" + rythm

            chunkedFlows[chunkName] = gatherAndMergeFlows(current, nextminusone, flows)

            current = next
        }
        return chunkedFlows
    }

    function gatherAndMergeFlows(start, last, flows) {
        let chunk = { flow: 0 }
        if (!flows) return chunk;

        let current = start
        while (current <= last) {
            chunk = mergeFlow(chunk, flows[current])
            next = moment(current, 'YYYYMMDD').add(1, "d").format('YYYYMMDD')
            current = next
        }
        return chunk
    }

    function round2(value) {
        return Math.round(value * 100) / 100
    }

    function round(value) {
        return Math.round(value)
    }
    function extendObject(obj, src) {
        if (src) {
            obj = obj || {}
            Object.keys(src).forEach(function(key) { if (obj[key]===undefined) obj[key] = src[key]; });
        }
        return obj;
    }
    function mergeFlow(oldFlow, flow, unit) {
        let merged = {}
        merged.unit = unit || oldFlow.unit || flow && flow.unit
        // account : if diff to array
        if ((oldFlow && oldFlow.account && Array.isArray(oldFlow.account)) || (flow && flow.account && Array.isArray(flow.account)) || (flow && oldFlow && oldFlow.account && flow.account && oldFlow.account != flow.account)) {
            merged.account = []
            if (oldFlow && oldFlow.account && Array.isArray(oldFlow.account))
                merged.account = [...new Set([...merged.account, ...oldFlow.account])];
            else if (oldFlow.account)
                merged.account.push(oldFlow.account)

            if (flow && flow.account && Array.isArray(flow.account))
                merged.account = [...new Set([...merged.account, ...flow.account])];
            else if (flow && flow.account)
                merged.account.push(flow.account)

        } else {
            merged.account = oldFlow.account || flow && flow.account
        }

        merged.amount = oldFlow.amount || 0
        merged.in = oldFlow.in || 0
        merged.out = oldFlow.out || 0

        let newBalance = (flow && flow.balance) || (oldFlow && oldFlow.balance)
        if (newBalance !== undefined) {
            merged.balance = round2(newBalance)
        }

        if (flow && flow.oldBalance || oldFlow && oldFlow.oldBalance)
            merged.oldBalance = extendObject(oldFlow.oldBalance, flow.oldBalance)

        if (flow && flow.in) {
            let inamount = convert(flow.in, flow.unit, merged.unit)
            merged.in += inamount
            merged.in = round2(merged.in) 
        }

        if (flow && flow.out) {
            let out = convert(flow.out, flow.unit, merged.unit)
            merged.out += out
            merged.out = round2(merged.out ) 
        }

        if (flow && flow.amount) {
            let amount = convert(flow.amount, flow.unit, merged.unit)
            merged.amount += amount
            merged.amount = round2(merged.amount ) 
            if (amount > 0 && typeof flow.in === "undefined") {
                merged.in += amount
                merged.in = round2(merged.in ) 
            } else if (typeof flow.out === "undefined") {
                merged.out += amount
                merged.out = round2(merged.out )
            }
        }

        if (flow && flow.negative || oldFlow && oldFlow.negative)
            merged.negative = extendObject(oldFlow.negative, flow.negative)

        return merged
    }

    function convert(value, unit, targetUnit) {
        if (unit && unit != targetUnit) {
            let factor = getConversionFactor(unit, targetUnit)
            value = value * factor
        }
        return value;
    }

    function getConversionFactor(unit, targetUnit) {
        if (units[unit][targetUnit])
            return units[unit][targetUnit]
        else
            throw new Error("no conversion for : " + unit + " to " + targetUnit)
    }
    // flows,account:{balances,unit,...}=>actualizeFlows=>actualFlows{day:{ amount, unit, account, balance, oldBalance,.. },...}
    function actualizeFlows(flows, balances) {
        let balance = 0
        _.reduce(flows, (flows, flow, day) => {
            if (flow.amount !== undefined)
                balance += flow.amount
            flow.balance = balance
            if (balances[day] !== undefined) {
                let oldBalance = { balance:flow.balance , }
                flow.balance = balances[day]
                balance = balances[day]

                oldBalance.deltaBalance= flow.balance - oldBalance.balance
                flow.oldBalance = flow.oldBalance || {}
                flow.oldBalance[day] = oldBalance
            }
            if (flow.balance < 0) {
                flow.negative = flow.negative || {}
                flow.negative[day] = flow.balance
            }
            return flows
        }, flows)

        return flows
    }

    function findPropOnObject(prop, source) {
        for (var property in source) {
            let found = undefined
            if (prop == property) {
                found = source[property];
            } else if (typeof source[property] === "object") {
                found = findPropOnObject(prop, source[property]);
            }
            if (found)
                return found
        }
        return undefined
    }

    function normalizeAmount(contract) {
        // set start
        // norm start
        if (!contract.amount)
            return
        contract.amount = -contract.amount
    }

    function normalizeTransfers(contracts) {

        return function(contract, key, level, path) {
            if (!contract.contract)
                return
            let transferContract =
                _(path.split("."))
                .filter(elem => elem)
                .unshift(contract.contract)
                .push(key)
                .reduce((current, pathElement) => {
                    //current[pathElement] = current[pathElement] || {};
                    current[pathElement] = inherit({}, current, contractProto, true)
                    return current[pathElement]
                }, contracts)
            clone(contract, true, transferContract)
            transferContract.amount = -transferContract.amount
            transferContract.contract = undefined
            transferContract.account = transferContract.transferAccount || transferContract.account
            transferContract.transferAccount = undefined
        }
    }

    function normalizeDates(contract) {
        // set start
        // norm start
        if (!contract.start)
            return
        normalizeDate(contract, "start")
        normalizeDate(contract, "end")
    }

    function normalizeDate(contract, prop) {
        // set start
        // norm start
        let date = contract[prop];
        if (date) {
            let endMarker = "end"
            if (date.indexOf(endMarker) == date.length - endMarker.length) {
                if (date.length != 6 + endMarker.length)
                    throw "date not YYYYMM formate: " + JSON.stringify(contract, null, 2)
                let begin = moment(date.substring(0, 6), 'YYYYMM')
                let end = begin.endOf('month');
                contract[prop] = end.format('YYYYMMDD')
            }
        }
    }

    function normalizeCalc(contract, prop, level, path, res, parent) {
        if (!isContract(contract)) return
        //if (typeof contract.amount == "string" ) {
        if (contract.calc == "auto:match:..") {
            // calc : parent amount: period - div by my period 
            let end = rythmNext(parseRythm(parent.rythm), parent.start)
            let amount = parent.amount

            let numberPeriods = moment(end, "YYYYMMDD").diff(parent.start, contract.rythm, true)
            let myAmount = amount / numberPeriods;
            contract.amount = round2(myAmount)
        }
        // else {
        //     throw "unknown path : "+contract.calc
        // }
        //}
    }

    // source, key, level, path, res, parent
    function autoamotization(contract, prop, level, path, res, parent) {
        if (!isContract(contract)) return
        let parsedRythm = parseRythm(contract.rythm)
        if (parsedRythm.rythm == "y" && parsedRythm.length > 1) {
            // calc : parent amount: period - div by my period 
            let end = rythmNext(parsedRythm, parent.start)
            let amount = contract.amount

            let newContract = { contract: "amortizations", rythm: "M", start: contract.start, transferAccount: contract.account, account: parent.account, }
            let numberPeriods = moment(end, "YYYYMMDD").diff(contract.start, newContract.rythm, true)
            let myAmount = amount / numberPeriods;
            newContract.amount = round2(myAmount)
            contract.amortizations = newContract
        }
    }

    function normaliseContracts(contracts, contractProto) {
        contracts = inherit(contracts, {}, contractProto, true)
        walkPojo(contracts, normalizeDates)
        walkPojo(contracts, normalizeAmount)
        walkPojo(contracts, autoamotization)
        walkPojo(contracts, normalizeTransfers(contracts))
        return contracts
    }

    // bring last balance before start day forward, if start day does not have balance ??
    // go down balances until >= start day, if start day not defined and there is one before copy it in on start day
    function bringFowardOldBalance(account, accountName) {
        // find last balance before start
        if (!isAcccount(account)) return
        if (account.balances && !account.balances[start]) {

            let last = _(account.balances).reduce((found, balance, day) => {
                if (day < start) {
                    return { day: day, balance: balance }
                }
                return found
            }, {})
            if (last && last.day) {
                // calc flows,balance until start
                let allFlows = genAllContractLines(normalisedContracts, last.day, start, 'd')

                let rolledUpFlows = genRollupFlows(last.day, start, allFlows.allFlows, [accountName], account.unit)

                let bals = {}
                bals[last.day] = last.balance
                let actualFlows = actualizeFlows(rolledUpFlows, bals)
                let end = _.findLastKey(actualFlows)
                // copy start balance to balances
                account.balances[start] = actualFlows[end].balance
            }
        }
    }

    function isTransfer(transfers, property) { return property == "transfers" }

    function normaliseAccounts(accounts, start, end, normalisedContracts, prototypeAccount) {

        let normalizedAcccounts = inherit(accounts, {}, prototypeAccount, true);

        walkPojo(normalizedAcccounts, bringFowardOldBalance)
        walkPojo(normalizedAcccounts, implementTransfers)

        function implementTransfers(transfers, property, level, path, res) {
            if (!isTransfer(transfers, property)) return
            _.each(transfers, transfer => {
                let toAccount = transfer.account
                let fromAccount = _.findLast(path.split("."))
                // create contracts: transfers.accountfrom, transfers.accountto
                normalisedContracts.transfers = normalisedContracts.transfers || {}
                normalisedContracts.transfers[toAccount] = normalisedContracts.transfers[toAccount] || {}
                let index = _.keys(normalisedContracts.transfers[toAccount]).length
                normalisedContracts.transfers[toAccount][index] = clone(transfer, true)

                normalisedContracts.transfers[fromAccount] = normalisedContracts.transfers[fromAccount] || {}
                index = _.keys(normalisedContracts.transfers[fromAccount]).length
                normalisedContracts.transfers[fromAccount][index] = clone(transfer, true)

                normalisedContracts.transfers[fromAccount][index].amount = -transfer.amount
                normalisedContracts.transfers[fromAccount][index].account = fromAccount


            })
        }

        return normalizedAcccounts
    }
    // deep copy of undefined attributes
    function inherit(source, parent, prototype, deep, target) {
        // filter parent 
         target = target || {}

        // copy source props
        //   if prop in prototype: deep copy/clone 
        for (var prop in source) {
            if (prototype[prop] !== undefined) {
                if (typeof source[prop] == "object") {
                    target[prop] = clone(source[prop], true)
                } else {
                    target[prop] = source[prop]
                }
            }
        }

        // inheit from parent
        for (var prop in parent) {
            if (prototype[prop] === null && target[prop] === undefined && parent[prop] !== undefined) {
                target[prop] = parent[prop]
                if (prototype.inherited) {
                    target.inherited = target.inherited || []
                    target.inherited.push(prop)
                }
            }
        }

        for (var prop in source) {
            if (prototype[prop] === undefined && typeof source[prop] == "object") {
                if (deep)
                    target[prop] = inherit(source[prop], target, prototype, deep)
                else
                    target[prop] = source[prop]
            }
        }

        return target
    }

    // deep copy, but not overwriting dest leaves
    function clone(source, deep, destination) {
        if (!destination)
            if (Array.isArray(source))
                destination = []
            else
                destination = {}
        for (var property in source) {
            if (typeof source[property] === "object" && deep) {
                if (Array.isArray(source[property]))
                    destination[property] = []
                else
                    destination[property] = {}
                clone(source[property], deep, destination[property]);
            } else {
                destination[property] = source[property];
            }
        }
        return destination
    }

    function walkPojo(source, iterator, key, level, path, parent) {

        if (level === undefined)
            level = 0
        if (path === undefined)
            path = "."
        let subPath = path
        if (key)
            subPath += key + "."
        let res;
        for (var property in source) {
            if (typeof source[property] === "object") {
                let subres = walkPojo(source[property], iterator, property, level + 1, subPath, source)
                if (subres !== undefined)
                    res = (res || []).concat(Array.isArray(subres) ? subres : [subres])
            }
        }
        res = iterator(source, key, level, path, res, parent)
        if (res !== undefined && !Array.isArray(res))
            res = [res]
        return res
    }

    Set.prototype.toJSON = function toJSON() {
        return [...Set.prototype.values.call(this)];
    }

    // function pluckMergeArrays(array,  property) {
    //     let res=[];
    //     if (array && Array.isArray(array)) {
    //         array.forEach(item=> { 
    //             res=res.concat(item && Array.isArray(item[property]) && item[property]|| [])
    //         }) }
    //     return res;
    // }


    const contractProto = {
        start: null,
        duration: null,
        end: null,
        amount: null,
        account: null,
        rythm: null,
        flows: [],
        unit: null,
        inherited: [],
        contract: "",
        transferAccount: "",
        calc: [],
    }
    const prototypeAccount = {
        unit: null,
        balances: [],
        inherited: [],
        transfers: []
    }
    </script>
    <script type="text/javascript">
    let normalisedContracts = (test) ? normaliseContracts(testContracts, contractProto) : normaliseContracts(contracts, contractProto)

    let normalizedAcccounts = (test) ? normaliseAccounts(testAccounts, start, end, normalisedContracts, prototypeAccount) : normaliseAccounts(accounts, start, end, normalisedContracts, prototypeAccount)


    // console.log(JSON.stringify(allAcctflows, null, 2))

    // gen all contracts: if dates or rythm change
    // gen all accounts: if above or unit change
    // refresh/redraw, generate, loop contracts, expand logic, css, 
    // budget examples, mine, a house?, retirement 
    // expand path, max/one level
    //   if below expanding: has children&&contract? show detail: show aggregate
    // 
    function collapse() {
        let $tr = $(this).closest('tr')
        let path = $tr.data("path")

        $('tr').each((index, tr) => {
            let $tr = $(tr)
            let myPath = $tr.data("path")

            if (path && (!myPath || !myPath.startsWith(path))) return

            let myIsDetail = $tr.hasClass("detail")
            let contract = $tr.data("contract")
            let hasChildren = $tr.data("aggregateCount")
            let hasDetail = $tr.data("hasDetail")

            let show = false
            // if equal paths
            // if has no children and has detail, show detail
            // else show rollup
            if (myPath == path) {
                if (myIsDetail && !hasChildren && hasDetail)
                    show = true
                else if (!myIsDetail && hasChildren)
                    show = true
                else
                    show = false
            } else
                show = false

            if (show)
                addExpandHandler($tr, expandone, "+")

            showRow($tr, show);
        })
        removeExpandHandler($tr, collapse, "-")

    }

    function expandmax() {
        let $tr = $(this).closest('tr')
        let path = $tr.data("path")

        $('tr').each((index, tr) => {
            let $tr = $(tr)
            let myPath = $tr.data("path")
            let hasChildren = $tr.data("aggregateCount")

            if (!myPath || path && (!myPath || !myPath.startsWith(path))) return

            let myIsDetail = $tr.hasClass("detail")
            let contract = $tr.data("contract")

            let isLeaf = myIsDetail && !hasChildren
            let show = false
            if (myIsDetail && isContract(contract))
                show = true
            else if (!myIsDetail && hasChildren > 1)
                show = true
            else
                show = false

            if (show && !isLeaf)
                addExpandHandler($tr, collapse, "-")

            showRow($tr, show);
        })
        removeExpandHandler($tr, expandmax)

    }

    function expandone(levelsIn) {
        let levels = typeof levelsIn === "number" ? levelsIn : 1
        let $tr = $(this).closest('tr')
        let path = $tr.data("path")
        let level = $tr.data("level")
        if (level === undefined) level = 0
        if (!path) path = "."

        $('tr').each((index, tr) => {
            let $tr = $(tr)
            let myPath = $tr.data("path")

            if (path && (!myPath || !myPath.startsWith(path))) return

            let myIsDetail = $tr.hasClass("detail")
            let myLevel = $tr.data("level")
            let contract = $tr.data("contract")
            let myIsContract = isContract(contract)
            let hasChildren = $tr.data("aggregateCount")

            let show = false
            if (myIsDetail && myIsContract && (level <= myLevel && level + levels >= myLevel))
                show = true
            else if (!myIsDetail && (!myIsContract && hasChildren > 1) && (level <= myLevel && level + levels >= myLevel))
                show = true
            else
                show = false
            let isLeaf = myIsDetail && !hasChildren
            if (!isLeaf) {
                if (show && (level <= myLevel && level + levels > myLevel))
                    addExpandHandler($tr, expandmax, "++")
                if (show && level + levels == myLevel)
                    addExpandHandler($tr, expandone, "+")
            }

            showRow($tr, show);
        })
        removeExpandHandler($tr, expandone)

    }

    function showRow($tr, show) {
        let row=$('td', $tr).first().data("rownumber")
        $trs = $('tr[data-rownumber='+row+"]")
        if (show)
            $trs.show()
        else
           $trs.hide()

    }
    function addExpandHandler($tr, handler, symbol) {
        $('td', $tr).first().on("click", handler).text(symbol)
    }

    function removeExpandHandler($tr, handler) {
        $('td', $tr).first().off("click", handler)
    }

    function mergeFlows(flows) {
        let count = 0
        let mergedFlow = _.reduce(flows, (merged, flow, day) => {
            count++
            return mergeFlow(merged, flow)
        }, {})
        mergedFlow.average = round(mergedFlow.amount / count)
        return mergedFlow
    }
    function prettyContract(contract) {
        return ""+ contract.amount +", rythm: "+ contract.rythm +(contract.unit?", unit: "+ contract.unit :"")
    }

    function prettyOldBalance(balance) {
        return " balance: "+balance.balance+", delta: "+ balance.deltaBalance
    }
    //   name
    //.     date,amount,unit,balance
    // gather contracts and indexes and flows before day until last oldbalance or begin
    function getReconcileInfos(allFlows, wind, day, previousBalanceDate, accountName) {
        let title = ""
        title += " "+day+" "+prettyOldBalance(wind.oldBalance[day])
        let sorted = _(allFlows.contracts).reduce((indexes, contract,index)=>{
             console.log(indexes,contract,index);
              if (isContract(contract) && contract.account==accountName) 
                indexes.push(index); 
             return indexes
         }
         , [])
        .reduce((list,index)=>{ 
            let totalFlow = getSpecFlows(day, allFlows.allFlows[index], previousBalanceDate)
            if (totalFlow)
                list.push({index:index, totalFlow: totalFlow})
            return list 
            },[])
        

        sorted = _(sorted)
        .orderBy(["totalFlow"],["asc"])
        sorted = sorted
        .reduce((text,list)=>{ 
            if (list.index) {
                let index = list.index
                text += "\n"; 
                text += "  "+list.totalFlow; 
                text += " : "+allFlows.paths[index]; 
                text += ": "+prettyContract(allFlows.contracts[index]); 
            }
            return text 
            },"")

            title += " "+ sorted

         return title   
    }
    function prettyFlow(flow) {
        return " amount: "+flow.amount+(flow.unit?", unit: "+flow.unit:"")+(flow.balance?", balance: "+flow.balance :"")
    }
    function getSpecFlows(day, flows,  previousBalanceDate){
        let totalFlow = _(flows).reduce((totalFlow,flow, flowDate)=>{
            if (flowDate<day && (!previousBalanceDate || previousBalanceDate<flowDate)) {
                totalFlow += flow.amount
            }
            return totalFlow 
        }, 0)
        return totalFlow;
    }
    function getPreviousBalanceDate(account, firstBalance) {
        return _(account.balances).reduce((max,bal,day)=>{ if(day<firstBalance && (!max || day>max)) max=day; return max},"")
    }
    function prettyNegatives(negatives) {
        return JSON.stringify(negatives, null, 2)
    }
    function refreshWindows() {

        let allFlows = genAllContractLines(normalisedContracts, start, end, windowSize)

        let allAccountNames = getAllAccountNames(normalizedAcccounts)
        let allAcctflows = genAllAccountLines(allAccountNames, normalizedAcccounts, allFlows.allFlows, start, end, targetCurrency, windowSize)

        let $tableEnd = createTable(chunkFlows(start, end, null, windowSize));

        {
            allFlows.allFlows.forEach((flows, index) => {
                let level = (allFlows.paths[index].match(/\./g) || []).length;
                if (allFlows.paths[index].length == 1)
                    level = 0;

                appendRow($tableEnd, allFlows.contracts[index], allFlows.allChunkedRowupFlows[index], mergeFlows(allFlows.allChunkedRowupFlows[index]), allFlows.paths[index].split(".").pop(), level, allFlows.paths[index], "rollup", true, allFlows.aggregateCounts[index], allFlows.immediateChildren && allFlows.immediateChildren.length, allFlows.hasDetail[index])

                appendRow($tableEnd, allFlows.contracts[index], allFlows.allChunkedFlows[index], mergeFlows(allFlows.allChunkedFlows[index]), allFlows.paths[index].split(".").pop(), level, allFlows.paths[index], "detail", true, allFlows.aggregateCounts[index], allFlows.immediateChildren && allFlows.immediateChildren.length, allFlows.hasDetail[index])
            })
        }

        {
            allAcctflows.accounts.forEach((flows, index) => {

                appendFooter($tableEnd, allAcctflows.accounts[index], allAcctflows.allChunkedFlows[index], mergeFlows(allAcctflows.allChunkedFlows[index]), allAcctflows.paths[index], undefined, allFlows)

            })

        }
        let totalFlows = genRollupFlows(start, end, allAcctflows.allChunkedFlows, undefined, targetCurrency)

        appendFooter($tableEnd, { unit: targetCurrency }, totalFlows, mergeFlows(totalFlows), "Totals", true)

        function createTable(windowedSeq) {
            $('#flowscontrol').empty();

            $('<span>').text("window:").append($input = $('<input>').val(windowSize).on('blur', (e) => {
                    windowSize = e.target.value;
                    refreshWindows()
                }))
                .appendTo($('#flowscontrol'))

            $('<span>').text("start:").append($input = $('<input>').val(start).on('blur', (e) => {
                    start = "" + e.target.value;
                    refreshWindows()
                }))
                .appendTo($('#flowscontrol'))

            $('<span>').text("end:").append($input = $('<input>').val(end).on('blur', (e) => {
                    end = "" + e.target.value;
                    refreshWindows()
                }))
                .appendTo($('#flowscontrol'))

            // $('<span>').text("targetAccounts:"+targetAccounts)
            //         .appendTo($('#flowscontrol'))

            $('<span>').text("currency:").append($('<input>').val(targetCurrency).on('blur', (e) => {
                    targetCurrency = e.target.value;
                    refreshWindows()
                }))
                .appendTo($('#flowscontrol'))

            let $table = $('<table>')
            $table.css("border", "1px solid #000");
            let $header = $('<tr>').appendTo(
                $table
//                .appendTo($('#flowsold'))
            )

            $header
                .append($('<td>').text("+-").on("click", expandmax))
                .append($('<td>').text("name")
                    .css("border", "1px solid #000"));

            let $header1 = $('<tr>')

            $header1
                .append($('<td>')
                    .text("+-").on("click", expandmax))
                .append($('<td>').text("name")
                    .css("border", "1px solid #000"));

            _.each(contractProto, (value, prop) => {
                if (value == null)
                    $header.append($('<td>').text(prop)
                        .css("border", "1px solid #000"));

            })
            _.each(contractProto, (value, prop) => {
                if (value == null)
                    $header1.append($('<td>').text(prop)
                        .css("border", "1px solid #000"));

            })

            let $header2 = $('<tr>')

            _.each(windowedSeq, (wind, day) => {
                $header.append($('<td>').text(day.split('-')[0])
                    .css("border", "1px solid #000")
                );
            })
            $header.append($('<td>').text("Total")
                .css("border", "1px solid #000"));

            _.each(windowedSeq, (wind, day) => {
                $header2.append($('<td>').text(day.split('-')[0])
                    .css("border", "1px solid #000")
                    .addClass("tableHeader")
                );
            })

            let $header3 = $('<tr>')
            $header3.append($('<td>').text("Total")
                .css("border", "1px solid #000")
                .addClass("tableHeader")
            );

            $header1.appendTo($('#leftHeaderData'))
            $header2.appendTo($('#rightHeaderData'))
            $header3.appendTo($('#endHeaderData'))
           return $table
        }

        function appendRow($appendPoint, targetContract, windowedFlows, total, contractName, level, path, cssClass, show, aggregateCount, hasChildren, hasDetail) {

            let $tr = $('<tr>')
                .data("path", path)
                .data("level", level)
                .data("aggregateCount", aggregateCount)
                .data("hasChildren", aggregateCount)
                .data("contract", targetContract)
                .data("hasDetail", hasDetail)
                .appendTo($appendPoint)
                //.on("click", toggle)
                .addClass(cssClass)

            let factor = 30
            let offset = 130
            let cssColor =  "rgb(" + (offset + level * factor) + "," + (offset + level * factor) + "," + (offset + level * factor) + ")"
           $tr.css("background-color",cssColor)

            let symbol = "+"
            if (cssClass == 'detail') {
                if (aggregateCount > 1)
                    symbol = "-"
                else
                    symbol = ""

            } else {

            }

            let $leftRow = $('<tr>')
            $leftRow
                .data("path", path)
                .data("level", level)
                .data("aggregateCount", aggregateCount)
                .data("hasChildren", aggregateCount)
                .data("contract", targetContract)
                .data("hasDetail", hasDetail)
                .appendTo($appendPoint)
                //.on("click", toggle)
                .addClass(cssClass)


            $tr.append(
                $('<td>')
                .text(symbol)
                .addClass('expand/collapse')
            )

            $leftRow.append(
                $('<td>')
                .text(symbol)
                .addClass('expand/collapse')
                .addClass("tableFirstCol")
            )

            $tr.append($('<td>')
                .text((contractName ? contractName : ""))
                .css("padding-left", ' ' + (level * 10) + "px")
                .css("border", "1px solid #000")
            );

            $leftRow.append($('<td>')
                .text((contractName ? contractName : ""))
                .css("padding-left", ' ' + (level * 10) + "px")
                .css("border", "1px solid #000")
                .addClass("tableFirstCol")
            );

            _.each(contractProto, (value, prop) => {
                if (value == null) {
                    let $td;
                    let contractvalue = targetContract[prop]
                    let flow1=_.chain(windowedFlows).values().head().value()
                    if (flow1 && flow1[prop]!== undefined && (prop=="account" || prop=="unit")) {
                        contractvalue= flow1[prop]
                    }
                    if (Array.isArray(contractvalue)) {
                        if (contractvalue.length>1) 
                            contractvalue = contractvalue[0]+",..."
                    }
                    $tr.append($td = $('<td>').text(contractvalue)
                        .css("border", "1px solid #000")
                        .css("padding-left", ' ' + (level * 10) + "px")
                    );
                    if (targetContract && targetContract.inherited && targetContract.inherited.indexOf(prop) != -1) {
                        $td.css("background-color", "lightgrey")
                    }
                }
            })

            _.each(contractProto, (value, prop) => {
                if (value == null) {
                    let $td;
                    let contractvalue = targetContract[prop]
                    let flow1=_.chain(windowedFlows).values().head().value()
                    if (flow1 && flow1[prop]!== undefined && (prop=="account" || prop=="unit")) {
                        contractvalue= flow1[prop]
                    }
                    if (Array.isArray(contractvalue)) {
                        if (contractvalue.length>1) 
                            contractvalue = contractvalue.join("<br/>")
                    }
                    $leftRow.append($td = $('<td>').html(contractvalue)
                        .css("border", "1px solid #000")
                        .css("padding-left", ' ' + (level * 10) + "px")
                        .addClass("tableFirstCol")
                    );
                    if (targetContract && targetContract.inherited && targetContract.inherited.indexOf(prop) != -1) {
                        $td.css("background-color", "lightgrey")
                    }
                }
            })

            let $rightRow = $('<tr>')

            if (cssClass == 'detail')
                _.each(windowedFlows, (wind, day) => {
                    $tr.append($('<td>')
                        .append($('<span>').text(wind.amount))
                        .css("border", "1px solid #000")
                        .css("padding-left", ' ' + (level * 10) + "px")
                    );
                })
            else
                _.each(windowedFlows, (wind, day) => {
                    let $td = $('<td>')
                    if (wind.in && wind.out) {
                        $td.append($('<span>').text("in:" + wind.in))
                            .append($('<br>'))
                            .append($('<span>').text("out:" + wind.out))
                            .append($('<br>'))
                    }

                    $tr.append($td
                        .append($('<span>').text(wind.amount))
                        .css("border", "1px solid #000")
                        .css("padding-left", ' ' + (level * 10) + "px")
                    );

                })

            if (cssClass == 'detail')
                _.each(windowedFlows, (wind, day) => {
                    $rightRow.append($('<td>')
                        .append($('<span>').text(wind.amount))
                        .css("border", "1px solid #000")
                        .css("padding-left", ' ' + (level * 10) + "px")
                    );
                })
            else
                _.each(windowedFlows, (wind, day) => {
                    let $td = $('<td>')
                    if (wind.in && wind.out) {
                        $td.append($('<span>').text("in:" + wind.in))
                            .append($('<br>'))
                            .append($('<span>').text("out:" + wind.out))
                            .append($('<br>'))
                    }

                    $rightRow.append($td
                        .append($('<span>').text(wind.amount))
                        .css("border", "1px solid #000")
                        .css("padding-left", ' ' + (level * 10) + "px")
                    );

                })

            if (cssClass == 'detail')
                _.each([total], (wind, day) => {
                    $tr.append($('<td>')
                        .append($('<span>').text(wind.amount))
                        .css("border", "1px solid #000")
                        .css("padding-left", ' ' + (level * 10) + "px")
                        .css("background-color", "white")
                    );
                })
            else
                _.each([total], (wind, day) => {
                    let $td = $('<td>')
                    if (wind.in && wind.out) {
                        $td
                            .append($('<span>').text("in:" + wind.in))
                            .append($('<br>'))
                            .append($('<span>').text("out:" + wind.out))
                            .append($('<br>'))
                    }
                    $tr.append($td
                        .append($('<span>').text(wind.amount))
                        .append($('<br>'))
                        .append($('<span>').text("avg:" + wind.average))
                        .css("border", "1px solid #000")
                        .css("padding-left", ' ' + (level * 10) + "px")
                        .css("background-color", "white")
                    );
                })

            let $endRow = $('<tr>')
            if (cssClass == 'detail')
                _.each([total], (wind, day) => {
                    $endRow.append($('<td>')
                        .append($('<span>').text(wind.amount))
                        .css("border", "1px solid #000")
                        .css("padding-left", ' ' + (level * 10) + "px")
                        .css("background-color", "white")
                    );
                })
            else
                _.each([total], (wind, day) => {
                    let $td = $('<td>')
                    if (wind.in && wind.out) {
                        $td
                            .append($('<span>').text("in:" + wind.in))
                            .append($('<br>'))
                            .append($('<span>').text("out:" + wind.out))
                            .append($('<br>'))
                    }
                    $endRow.append($td
                        .append($('<span>').text(wind.amount))
                        .append($('<br>'))
                        .append($('<span>').text("avg:" + wind.average))
                        .css("border", "1px solid #000")
                        .css("padding-left", ' ' + (level * 10) + "px")
                        .css("background-color", "white")
                    );
                })

            if (show)
                $tr.show();
            else
               $tr.hide();

            //show = true 

            if (show)
                $leftRow.show();
            else
                $leftRow.hide();
            $leftRow.appendTo($('#leftData')).css("background-color",cssColor)

            if (show)
                $rightRow.show();
            else
                $rightRow.hide();
            $rightRow.appendTo($('#rightData')).css("background-color",cssColor)

            if (show)
                $endRow.show();
            else
                $endRow.hide();
            $endRow.appendTo($('#endData')).css("background-color",cssColor)

        }

        function appendFooter($appendPoint, targetContract, windowedFlows, total, contractName, isTotalLine, allFlows) {

            let $tr = $('<tr>').appendTo($appendPoint)

            let $footer1 = $('<tr>')
            let $footer2 = $('<tr>')
            let $footer3 = $('<tr>')


            if (isTotalLine) {
                $tr.css("background-color", "white")
                $footer1.css("background-color", "white")
                $footer2.css("background-color", "white")
                $footer3.css("background-color", "white")
            }
            else {
                $tr.css("background-color", "yellow")
                $footer1.css("background-color", "yellow")
                $footer2.css("background-color", "yellow")
                $footer3.css("background-color", "yellow")
            }

            $tr.append($('<td>').text(''))
            $tr.append($('<td>').text(contractName)
                .css("border", "1px solid #000"));

            $footer1.append($('<td>').text(''))
            $footer1.append($('<td>').text(contractName)
                .css("border", "1px solid #000"));

            _.each(contractProto, (value, prop) => {
                if (value == null)
                    $tr.append($('<td>').text(targetContract[prop])
                        .css("border", "1px solid #000"));

            })

            _.each(contractProto, (value, prop) => {
                if (value == null)
                    $footer1.append($('<td>').text(targetContract[prop])
                        .css("border", "1px solid #000"));

            })

            _.each(windowedFlows, (wind, day) => {
                let $td = $('<td>')

                if (wind.in && wind.out) {
                    $td
                        .append($('<span>').text("in:" + wind.in))
                        .append($('<br>'))
                        .append($('<span>').text("out:" + wind.out))
                        .append($('<br>'))
                }

                $tr.append($td.append($('<span>').text(wind.amount))
                    .append($('<br>'))
                    .append($bal = $('<span>').text(" (" + (wind.balance ? wind.balance : '0') + ")"))
                    .css("border", "1px solid #000")
                );

                if (wind.oldBalance !== undefined) {
                    $bal.css("color", "black")
                    $bal.css("font-weight", "bold")
                }

                if (wind.negative !== undefined) {
                    $bal.css("color", "red")
                    $bal.css("font-weight", "bold")
                }
            })

            _.each(windowedFlows, (wind, day) => {
                let $td = $('<td>')

                if (wind.in && wind.out) {
                    $td
                        .append($('<span>').text("in:" + wind.in))
                        .append($('<br>'))
                        .append($('<span>').text("out:" + wind.out))
                        .append($('<br>'))
                }

                $footer2.append($td.append($('<span>').text(wind.amount))
                    .append($('<br>'))
                    .append($bal = $('<span>').text(" (" + (wind.balance ? wind.balance : '0') + ")"))
                    .css("border", "1px solid #000")
                );

                if (wind.oldBalance !== undefined) {
                    $bal.css("color", "black")
                    $bal.css("font-weight", "bold")
                    // pop up with flows details: contracts/flows since last oldbalance: amount,unit,date,balance
                    let firstBalance = _(wind.oldBalance).keys().head()
                    if (!isTotalLine) {
                        $bal.attr("title", getReconcileInfos(allFlows, wind, firstBalance, getPreviousBalanceDate(targetContract, firstBalance), contractName))
                    }
                    if (firstBalance) {
                        if (Math.abs(wind.oldBalance[firstBalance].deltaBalance)>Math.abs(deltaBalanceThreshold)) {
                            if (wind.oldBalance[firstBalance].deltaBalance>0) {
                                $bal.css("color", "green")
                            }
                            else {
                                $bal.css("color", "red")
                            }
                        }
                    }
                }

                if (wind.negative !== undefined) {
                    $bal.css("color", "orange")
                    $bal.css("font-weight", "bold")
                    // list 
                    $bal.attr("title",prettyNegatives(wind.negative))
                }
            })

            _.each([total], (wind, day) => {
                let $td = $('<td>')

                if (wind.in && wind.out) {
                    $td
                        .append($('<span>').text("in:" + wind.in))
                        .append($('<br>'))
                        .append($('<span>').text("out:" + wind.out))
                        .append($('<br>'))
                        .append($('<span>').text(wind.amount))
                        .append($('<br>'))
                }

                $tr.append(
                    $td
                    .append($bal = $('<span>').text(" (" + (wind.balance ? wind.balance : '0') + ")"))
                    .css("border", "1px solid #000")
                    .css("background-color", "white")
                );

                if (wind.oldBalance !== undefined) {
                    $bal.css("color", "black")
                    $bal.css("font-weight", "bold")
                }

                if (wind.negative !== undefined) {
                    $bal.css("color", "orange")
                    $bal.css("font-weight", "bold")
                }
            })

            _.each([total], (wind, day) => {
                let $td = $('<td>')

                if (wind.in && wind.out) {
                    $td
                        .append($('<span>').text("in:" + wind.in))
                        .append($('<br>'))
                        .append($('<span>').text("out:" + wind.out))
                        .append($('<br>'))
                        .append($('<span>').text(wind.amount))
                        .append($('<br>'))
                }

                $footer3.append(
                    $td
                    .append($bal = $('<span>').text(" (" + (wind.balance ? wind.balance : '0') + ")"))
                    .css("border", "1px solid #000")
                    .css("background-color", "white")
                );

                if (wind.oldBalance !== undefined) {
                    $bal.css("color", "black")
                    $bal.css("font-weight", "bold")
                }

                if (wind.negative !== undefined) {
                    $bal.css("color", "red")
                    $bal.css("font-weight", "bold")
                }
            })

            if (isTotalLine) {
               $footer1.appendTo($('#leftFooterTotalData'))
               $footer2.appendTo($('#rightFooterTotalData'))
               $footer3.appendTo($('#endFooterTotalData'))
            }
            else {
               $footer1.appendTo($('#leftFooterData'))
               $footer2.appendTo($('#rightFooterData'))
               $footer3.appendTo($('#endFooterData'))

            }
        }


        expandone(2)

        adjustTable($('#flows'))

    }

    $(refreshWindows)


    function adjustTable($anchor) {

        function toArray($selector) {
            let res = []
            $selector.each((i, elem) => {
                res.push(elem)
            })
            return res
        }

        function doTableSizing($anchor) {
            let alltds = []; 
            let $rowsleft = $('.headerminorleft tr,.dataminorleft tr,.footerminorleft tr,.footerminortotalleft tr', $anchor);
            let $rowsright = $('.headerminorright tr,.dataminorright tr,.footerminorright tr,.footerminortotalright tr', $anchor);
            let $rowsend = $('.headerminorend tr,.dataminorend tr,.footerminorend tr,.footerminortotalend tr', $anchor);
            let col, row, max = 0;
            let numrows = $rowsleft.length;
            if ($rowsleft.length!=$rowsright.length || $rowsleft.length!=$rowsend.length)
                throw "unequal rows "
            for (row = 0; row < numrows; row++) {
                let max = 0;
                let tds = toArray($('td', $rowsleft.get(row))).concat(toArray($('td', $rowsright.get(row)))).concat(toArray($('td', $rowsend.get(row))))
                $($rowsleft.get(row)).attr("data-rownumber", row)
                $($rowsright.get(row)).attr("data-rownumber", row)
                $($rowsend.get(row)).attr("data-rownumber", row)
                $(tds[0]).attr("data-rownumber", row)
                tds.forEach(function(elem) {
                    max = Math.max($(elem).height(), max);
                    alltds.push(elem)
                })
                tds.forEach(function(elem) {
                    $(elem).height(max);
                })
            }
            let numcols = alltds.length / numrows;
            for (max = 0, col = 0; col < numcols; col++) {
                if (col==numcols-1)
                    console.log("here")
                for (max = 0, row = 0; row < numrows; row++) {
                    let index = col + row * numcols;
                    max = Math.max($(alltds[index]).width(), max);
                    if (max>300)
                        console.log("there")
                }
                for (row = 0; row < numrows; row++) {
                    let index = col + row * numcols;
                    $(alltds[index]).width(max);
                }
            }
        }

        function fnScroll() {
            $('.headerminorright>div,.footerminorright>div,.footerminortotalright>div', $anchor).scrollLeft($('.dataminorright>div', $anchor).scrollLeft());
            $('.dataminorend>div,.dataminorleft>div').scrollTop($('.dataminorright>div', $anchor).scrollTop());
        };

        function fnScrolll() {
            $('.dataminorend>div,.dataminorright>div').scrollTop($('.dataminorleft>div', $anchor).scrollTop());
        };

        function fnScrolle() {
            $('.dataminorleft>div,.dataminorright>div').scrollTop($('.dataminorend>div', $anchor).scrollTop());
        };

        function fnScrollh() {
            $('.dataminorright>div,.footerminorright>div,.footerminortotalright>div', $anchor).scrollLeft($('.headerminorright>div', $anchor).scrollLeft());
        };
        function fnScrollhf() {
            $('.dataminorright>div,.headerminorright>div,.footerminortotalright>div', $anchor).scrollLeft($('.footerminorright>div', $anchor).scrollLeft());
            $('.footerminorend>div,.footerminorleft>div').scrollTop($('.footerminorright>div', $anchor).scrollTop());
        };
        function fnScrolllf() {
            $('.footerminorend>div,.footerminorright>div').scrollTop($('.footerminorleft>div', $anchor).scrollTop());
        };
        function fnScrolllfe() {
            $('.footerminorleft>div,.footerminorright>div').scrollTop($('.footerminorend>div', $anchor).scrollTop());
        };
        function fnScrollht() {
            $('.dataminorright>div,.footerminorright>div,.headerminorright>div', $anchor).scrollLeft($('.footerminortotalright>div', $anchor).scrollLeft());
        };

        $('td', $anchor)
            .attr('nowrap', 'nowrap');

        $('.dataminorright>div', $anchor).on('scroll', fnScroll);
        $('.dataminorleft>div', $anchor).on('scroll', fnScrolll);
        $('.dataminorend>div', $anchor).on('scroll', fnScrolle);

        $('.headerminorright>div', $anchor).on('scroll', fnScrollh);
        $('.footerminorright>div', $anchor).on('scroll', fnScrollhf);
        $('.footerminorleft>div', $anchor).on('scroll', fnScrolllf);
        $('.footerminorend>div', $anchor).on('scroll', fnScrolllfe);
        $('.footerminortotalright>div', $anchor).on('scroll', fnScrollht);

        $('.dataminorleft>div,.dataminorright>div', $anchor)
            .css('overflow', 'scroll')
            .css('position', 'relative'); 
        $('.headerminorleft>div,.headerminorright>div,.footerminorleft>div,.footerminorright>div,.footerminortotalright>div,.footerminorend>div', $anchor)
            .css('overflow', 'scroll')
            .css('position', 'relative'); 

        doTableSizing($anchor);

        function setMaxSize() {
            let offset = $('.dataminorleft>div').offset().left + $('.dataminorleft>div').width()+ $('.dataminorend>div').width();
            let wwidth = $(window).width();
            let leftover = wwidth - offset * 1.05;
            $('.headerminorright>div,.dataminorright>div,.footerminorright>div,.footerminorright>div,.footerminortotalright>div', $anchor).css('max-width', leftover);

            offset = $('.headerminorleft>div').offset().top + $('.headerminorleft>div').height()+ $('.footerminortotalleft>div').height();
            let wheight = $(window).height();
            leftover = wheight - offset * 1.05;
            let sharefraction =0.75
            let share = leftover * sharefraction
            let accountshare = leftover * (1.0-sharefraction)
            $('.dataminorleft>div,.dataminorright>div,.dataminorend>div', $anchor).css('max-height', share).css('height', share);
            $('.footerminorleft>div,.footerminorright>div,.footerminorend>div', $anchor).css('max-height', accountshare).css('height', accountshare);
        };
        setMaxSize();
        doTableSizing($anchor);
        let rtime;
        let timeout = false;
        let delta = 200;

        function resizeTimer() {
            rtime = new Date();
            if (timeout === false) {
                timeout = true;
                setTimeout(resizeend, delta);
            }
        };

        $(window).resize(resizeTimer);

        function resizeend() {
            if (new Date() - rtime < delta) {
                setTimeout(resizeend, delta);
            } else {
                //alert('Done resizing');
                setMaxSize();
                timeout = false;
            }
        }

    };
    </script>
    <style type="text/css">
    .rollup {
        font-weight: bold;
    }

    .detail {
        text-decoration: underline;
    }
    </style>
</head>

<body>
    <div id="flowscontrol"> </div>

    <table id="flows" cellspacing="0" cellpadding="0" border="0">
        <tr>
            <td id="firstTd" class="headerminorleft">
                <div style="overflow:hidden;">
                    <table id="leftHeaderData" cellspacing="0" cellpadding="0" border="1">
                    </table>
                </div>
            </td>
            <td class="headerminorright">
                <div id="divHeader" style="overflow:hidden;">
                    <table id="rightHeaderData" cellspacing="0" cellpadding="0" border="1">
                    </table>
                </div>
            </td>
            <td class="headerminorend">
                <div id="divHeaderEnd" style="overflow:hidden;">
                    <table id="endHeaderData" cellspacing="0" cellpadding="0" border="1">
                    </table>
                </div>
            </td>
        </tr>
        <tr>
            <td valign="top" class="dataminorleft">
                <div id="firstcol" style="overflow: scroll;height:500px">
                    <table id="leftData"  cellspacing="0" cellpadding="0" border="1">
                    </table>
                </div>
            </td>
            <td valign="top" class="dataminorright">
                <div id="table_div" style="overflow: scroll;height:500px;position:relative">
                    <table id="rightData"  cellspacing="0" cellpadding="0" border="1">
                    </table>
                </div>
            </td>
            <td valign="top" class="dataminorend">
                <div id="table_div_end" style="overflow: scroll;height:500px;position:relative">
                    <table id="endData" cellspacing="0" cellpadding="0" border="1">
                    </table>
                </div>
            </td>
        </tr>
        <tr>
            <td id="footerTd" class="footerminorleft">
                <div style="overflow:hidden;">
                    <table id="leftFooterData" cellspacing="0" cellpadding="0" border="1">
                    </table>
                </div>
            </td>
            <td class="footerminorright">
                <div id="divFooter" style="overflow:hidden;">
                    <table id="rightFooterData" cellspacing="0" cellpadding="0" border="1">
                    </table>
                </div>
            </td>
            <td class="footerminorend">
                <div id="divFooterEnd" style="overflow:hidden;">
                    <table id="endFooterData" cellspacing="0" cellpadding="0" border="1">
                    </table>
                </div>
            </td>
        </tr>
        <tr>
            <td id="footerTotalTd" class="footerminortotalleft">
                <div style="overflow:hidden;">
                    <table id="leftFooterTotalData" cellspacing="0" cellpadding="0" border="1">
                    </table>
                </div>
            </td>
            <td class="footerminortotalright">
                <div id="divFooterTotal" style="overflow:hidden;">
                    <table id="rightFooterTotalData" cellspacing="0" cellpadding="0" border="1">
                    </table>
                </div>
            </td>
            <td class="footerminortotalend">
                <div id="divFooterTotalEnd" style="overflow:hidden;">
                    <table id="endFooterTotalData" cellspacing="0" cellpadding="0" border="1">
                    </table>
                </div>
            </td>
        </tr>
    </table>
    <div id="flowsold"> </div>
</body>

</html>